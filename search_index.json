[
["index.html", "컴퓨터 과학 언플러그드 세번째 비트 0.1 한국어 번역 0.2 감사의 말씀 0.3 들어가며", " 컴퓨터 과학 언플러그드 이광춘 번역 2017-10-09 세번째 비트 컴퓨터 과학 번역 목적 정보 불평등(Digital Divide)을 기회(Opportunites)로 만드는 계기가 대한민국 누구에게나 공평(Fair)하게 주여져야 합니다. - xwMOOC - 정보 불평등(Digital Divide)을 기회로 전환하는 컴퓨터 소프트웨어 교육 xwMOOC 프로젝트 중의 일환이며, 일부 G-창업 프로젝트 경기중소기업종합지원센터 지원을 받았습니다. 컴퓨터 과학 언플러그드는 Computer Science Unplugged 책에 기반하고 있으며, 한국적인 상황을 최대한 반영하여 내용 및 삽화를 일부 수정하였습니다. 또한, 컴퓨터 과학 언플러그드 공유 및 협업을 위해 GitHub에 그동안 작업결과가 정리되어 있다. 특히, 소프트웨어 카펜트리(Software Carpentry) 템플릿을 사용한 것이 도움이 많이 되었다. 한국어 번역 및 삽화 작업에 도움을 주신 분들은 다음과 같다. 한국어 프로젝트 참여자 및 원저작자 정보 한국어 번역: 이광춘 한국어 삽화: 문춘경 저자: Tim Bell, Ian H. Witten, Mike Fellows 실험수업: Robyn Adams and Jane McKenzie 삽화: Matt Powell 한글 컴퓨터 과학 언플러그드 버젼 2017년 10월 : 전자책 버젼 및 신규 콘텐츠 보강 2016년 1월 : EBS 링크, 소프트웨어 세상 제작 동영상 링크, 소프트웨어 세상 2015년 05월: 컴퓨터 과학 언플러그드 3.1 버젼 한글 번역 완료 HTML/PDF/E-PUB 무료 전자책 배포 인터넷에 대한 신규 활동 추가, 로고 변경 버젼 3.0에서 Part I, Part II로 양분되었던 교재(MS 워드)가 하나로 합쳐짐. 교육과정이 뉴질랜드 중심에서 글로벌 교육체계에 맞춰 변경. 한국어 언플러그드 교재를 PDF, E-PUB, HTML로 다양화하여 제공. 2015년 03월: 컴퓨터 과학 언플러그드 3.0 버젼 MS 워드 기반에서 마크다운 공개 소프트웨어 플랫폼 변환(GitHub) 2015년 02월: 컴퓨터 과학 언플러그드 3.0 버젼 삽화 한국화 작업 2015년 01월: 컴퓨터 과학 언플러그드 3.0 버젼 Part IV,V,VI 번역 (MS 워드) 2014년 08월: 컴퓨터 과학 언플러그드 3.0 버젼 Part I,II,III 번역 (MS 워드) 0.1 한국어 번역 우리나라의 산업발달과정을 보면 1950~1960년대 수입대체를 목표로 신발, 섬유가 중심이 된 경공업시대, 1970~1980년 수출진흥을 목표로 철강, 조선, 자동차가 중심이 된 중공업시대, 1990~2000년대 기술혁신을 통한 반도체, 핸드폰, 디스플레이가 중심이 된 ICT 산업을 지나 2010~2020년대는 소프트웨어, 콘텐트, 과학기술이 중심이 되는 융합•지식 창조산업 시대로 발전해 갈 것으로 기대하고 있다. 첫 인터넷 웹 브라우저를 만든 마크 앤더슨은 소프트웨어가 세상을 먹고 있다(“Software is eating the world”)는 자극적인 표현으로 2011년 월스트리트 저널에 에세이를 썼고, 카네기멜론 대학의 쟈넷 윙 교수는 이론적 사고(Theoretical Thinking), 실험적 사고(Experimental Thinking))와 더불어 정보적 사고(Computational Thinking)가 현재도 그렇지만 앞으로 인간의 사고를 지배하는 중추적인 역할을 할 것을 주장했다. 이들의 결과는 정보적 사고를 배운 사람과 소프트웨어를 이해하고 활용하는 사람과 그렇지 못한 사람과의 차이는 산업경제의 빈부격차보다 더 큰 디지털 경제의 정보 불평등(Digital Divide)를 야기할 것으로 예측했다. 정부는 ’14년 7월 세계 경제, 사회 환경이 소프트웨어 중심사회로 급격히 변화하고 있으며, 소프트웨어가 혁신과 성장, 가치창출의 중심이 되고, 개인•기업•국가의 경쟁력을 좌우하는 중요한 역할을 하고 있음에도 불구하고, 우리나라는 범정부적, 국민적 관심이 미흡한 상황이라고 진단하고, 미국, 영국, 이스라엘 등 선진국과 마찬가지로, 초•중•고에서 소프트웨어를 필수로 이수할 수 있는 방안을 강구하고 있다. 하지만, 지금까지 소프트웨어가 고등교육과 직업 교육에 초점이 맞추어줘서 초•중•고 및 소프트웨어에 관심을 가지고 있는 일반인이 접근하기에는 높은 장벽이 있었으나, ’컴퓨터 과학 언플러그드 (Computer Science Unplugged)’를 통해서 소프트웨어를 처음 접하거나, 원리를 이해하고자 하는 분들에게는 큰 도움이 되고 특히, 컴퓨터적 사고 (Computational Thinking)에 대한 입문으로적 적합할 것으로 생각된다. 컴퓨터 과학 언플러그드는 정보 불평등 해소하고, 대한민국 전 국민을 단돈 천원($1) 정보교육으로 행복한 세상 만들기 위한 정보 소프트웨어 교육 xwMOOC 프로젝트 중의 하나이며, 정보교육을 위한 파이썬, 소프트웨어 카펜트리 등 다양한 프로젝트가 진행중이다. 많은 분들이 번역 및 감수에 참여하여 빠른 시간 내에 번역이 완료될 수 있었으며, 문춘경, 김이정님이 삽화와 그래픽 디자인에 도움을 주셨고, 위키 플랫폼 구축과 xwMOOC 클라우드 서비스를 운영해 주고 계신 한정수님, 그리고 프로젝트를 지원해주신 강환범님과 문용규 사장님께 특별한 감사를 드립니다. 이광춘 경기도 과천 ’14년 12월 0.2 감사의 말씀 많은 어린이와 선생님 모두가 아이디어를 개선하도록 도움을 주셨습니다. 캐나다 브리티쉬 콜롬비아 빅토리아 사우스 파크 소재의 셜리 초등학교(Shirley Primary School), 이람 초등학교(Ilam Primary School), 뉴질랜드 크리스트 처치 웨스트번(Westburn Primary School)초등학교 선생님과 아이들이 초기 실험적 활동에 참여해 주셨습니다. 학습활동에 환대해 주셨으며, 여러 활동이 건설적으로 될 수 있도록 아낌없는 조언을 주신 Linda Picciotto, Karen Able, Bryon Porteous, Paul Cathro, Tracy Harrold, Simone Tanoa, Lorraine Woodfield, Lynn Atkinson 분께 특별한 감사의 말씀을 전한다. Gwenda Bensemann는 우리를 위해서 몇몇 활동을 시범적으로 수행해 주셨고, 변경 점에 대해서 조언을 주셨습니다. Richard Lynders, Sumant Murugesh 두 분은 학습활동을 도와주셨습니다. 일부 암호학 활동에서는 Ken Noblitz분이 도움을 주셨습니다. Kathy Beveridge 도움으로 Victoria “Mathmania”그룹활동 아래 몇몇 활동은 이루어졌습니다. 초기 삽화는 Malcolm Robinson, Gail Williams 도움을 주셨고, Hans Knutson으로부터의 조언도 도움이 되었습니다. Matt Powell도 언플러그드 프로젝트가 발전되는 동안 값진 도움을 주셨습니다. 이 책이 발전되는 초기단계 아낌없는 후원을 해주신 Brian Mason Scientific and Technical Trust에 무척 감사 드립니다. 도움이 되는 제안을 많이 해주시고 활동을 시범적으로 진행해 주신 Paul, Ruth Ellen Howard에 특별한 감사를 드립니다. Peter Henderson, Bruce McKenzie, Joan Mitchell, Nancy Walker-Mitchell, Gwen Stark, Tony Smith, Tim A. H. Bell , Mike Hallett, Harold Thimbleby는 많은 유용한 코멘트를 주셨습니다. 이 책이 있게 지원해준 가족 Bruce, Fran, Grant, Judith, Pam에게 많은 빚을 지고 있고, Andrew, Anna, Hannah, Max, Michael, Nikki는 이번 작업에 영감을 주었고 시범활동을 수행한 첫 아이들입니다. 언플러그드 프로젝트를 후원해고 자유롭게 다운로드될 수 있는 이 책을 만들게 해준 구글에 특별한 감사를 전합니다. 언플러그드 활동에 대해서 조언과 코멘트를 언제나 환영합니다. 저자들은 csunplugged.org를 통해서 만날 수 있습니다. 0.3 들어가며 컴퓨터는 이제 어디에나 있다. 컴퓨터를 어떻게 사용할지를 배울 필요가 있고 여러분 중 많은 분들은 매일 컴퓨터를 사용합니다. 그러나 컴퓨터는 어떻게 작동할까요? 컴퓨터는 어떻게 생각할까요? 그리고, 사람들은 컴퓨터를 더 빠르고 더 좋게 만들까요? 컴퓨터 과학은 이런 질문을 탐구하는 매력적인 분야입니다. 실제로는 아이들이 컴퓨터를 사용하지 않고, 다양한 연령대의 어린이를 위해 고안된 이 책의 쉽고 재미있는 활동은 여러분들을 컴퓨터가 어떻게 작동하는지에 대한 핵심적인 부문에 대해서 소개합니다. 이 책은 심화나 방과후 학교 확장 프로그램으로 혹은 정규 수업시간에 효과적으로 사용될 수도 있다. 여러분의 자녀들과 컴퓨터의 원리를 배우기 위해서 컴퓨터 전문가일 필요는 없습니다. 간략하게 설명된 배경정보를 가진 다양한 활동들이 이 책에 담겨 있다. 모든 문제에 대한 답은 제공되며 각각의 활동은 연관된 활동을 설명하는 ‘실제 컴퓨터 적용 (What’s it all about?)’ 세션으로 마무리된다. 예를 들어, 이진수 탐구, 매핑과 그래프, 패턴과 정렬 문제, 암호학처럼 많은 활동은 수학에 기반하고 있다. 다른 활동은 컴퓨터가 어떻게 작동하는지에 대한 지식과 이해력, 기술 과정과 연관된다. 자녀분들은 의미 있는 커뮤니케이션, 문제해결, 창의성, 사고력 기술 향상에 적극적으로 참여한다. 이 책과 더불어“언플러그드(Unplugged)” 프로젝트로 csunplugged.org 사이트에 많은 온라인 무료 동영상, 사진, 추가 자료들이 올라가 있다. 3명의 컴퓨터 과학 강사와 두 명의 선생님이 이 책의 집필에 참여하였으며 실제 학교 수업의 경험을 반영했다. 많은 컴퓨터의 주요 개념이 실제 컴퓨터 없이 교육이 가능하다는 것을 확인했다. 때때로 컴퓨터는 학습의 교란요소가 되기도 했다. 그래서 컴퓨터의 전원을 빼고(unplug your computer), 컴퓨터 과학이 무엇인지 바로 학습하세요. 이 책은 구글 덕분에 개인 및 교육 목적으로 자유로이 다운로드 해서 사용 가능하다. 크리에이티브 커먼즈 라이선스 (Creative Commons Attribution-NonCommercial-Share Alike)로 배포된다. 여러분은 자유로이 공유(복사, 배포, 전달)할 수 있다. 또한, 리믹스를 할 수도 있다. 이러한 이용은 다음의 사항을 만족할 때만 가능하다. 저작자를 명시하여야 하며, 상업적 목적으로 사용이 가능하지 않고, 여러분이 이 책의 내용에 근거하여 변형이나 변경을 한다면 동일한 라이선스를 적용하여야 한다. 좀더 자세한 사항은 CC BY-NC-SA 3.0의 검색을 통해 확인할 수 있다. 여러분이 교육환경에 이 교재를 적극적으로 사용하고, 책을 복사하고, 책에 딸려 있는 워크시트를 학생들에게 배포하는 것을 권장한다. 저자에게 질문과 제안점을 기탄없이 보내기 바랍니다. (자세한 사항은 csunplugged.org참조 바란다.) 이 책은 여러 언어로 번역이 되었거나, 번역이 진행되고 있다. 번역본에 대한 자세한 사항은 웹사이트를 확인 바란다. "],
["data-structure.html", "Chapter 1 제 1 부 1.1 점의 개수를 세다 - 이진수 (Binary Number) 1.2 숫자로 색깔 표현하기 - 이미지 표현 1.3 다시 말할 수 있어요! - 텍스트 압축 1.4 카드 뒤집기 마술 - 오류 탐지 및 수정 1.5 질문 20 개 - 정보 이론", " Chapter 1 제 1 부 정보를 나타내는 원재료 — 데이터 점의 개수를 세다—이진수 숫자로 색깔 표현하기—이미지 표현 다시 말할 수 있어요!—텍스트 압축 카드 뒤집기 마술—오류 탐지 및 수정 질문 20개—정보 이론 데이터: 정보를 나타내는 원재료 컴퓨터로 정보를 어떻게 저장할까요? 컴퓨터(Computer)라는 말은 라틴어 'computare'에 기원하는데 계산하고 더한다는 의미를 지니지만, 오늘날 컴퓨터는 거대한 계산기 이상이다. 컴퓨터는 도서관도 될 수 있으며, 컴퓨터로 글을 작성할 수 있으며, 정보를 찾고, 음악을 연주하고, 영화를 보기도 한다. 그런데 컴퓨터는 이렇게 많은 모든 정보를 어떻게 저장할까? 믿든 믿지 않든, 컴퓨터는 단지 두 가지만을 사용한다. 영('0')과 일('1')이다. 데이터와 정보의 차이는 무얼까? 데이터는 원재료, 즉 컴퓨터가 작업하는 숫자다. 컴퓨터는 여러분과 내가 이해할 수 있는 데이터를 정보(문자, 숫자, 그림)로 변환한다. 숫자, 글자, 단어, 그림이 어떻게 영('0')과 일('1')로 변환될까? 제 1부에서는 이진수(binary number)가 무엇인지, 컴퓨터가 어떻게 그림을 그리는지, 팩시밀리 송수신기가 어떻게 동작하고, 대량의 정보를 저장하는 효율적인 방법이 무엇인지, 오류가 생기는 것을 어떻게 막을 수 있는지, 그리고 저장하려는 정보의 양을 어떻게 측정되는지를 배울 것이다. 1.1 점의 개수를 세다 - 이진수 (Binary Number) 1.1 개요 컴퓨터의 데이터는 일련의 영과 일로 저장되고 전송된다. 단지 이 두 표식을 통해서 어떻게 언어와 숫자를 표현할 수 있을까? 1.1 교과학습 연계 수학: 숫자를 다른 진법으로 살펴보기. 이진법으로 숫자를 표현하기. 수학: 순열 패턴, 순열 패턴 규칙 기술하기. 이진법 패턴과 연관성 1.1 기술 계수 (Counting) 매칭 (Matching) 순서화 (Sequencing) 1.1 나이 7세 이상 1.1 학습 교재 이진 카드 5개가 데모용으로 필요합니다. 특히, A4 크기의 웃는 얼굴의 점 스티커 카드가 좋습니다. 아이마다 필요한 것 카드 5벌. 마스터 복사본: 카드에 이진수 표시된 자른 것 워크시트 학습: 이진수 필요에 따라 추가학습에 아이마다 필요한 것 워크시트 활동: 이진수 작업하기 워크시트 활동: 비밀 메시지 보내기 워크시트 활동: 팩스 기계와 모뎀 워크시트 활동: 31보다 큰 수 세기 워크시트 활동: 이진수 심화 1.1 언플러그드 활동 동영상 EBS 링크 동영상 언플러드그 동영상 1.1.1 이진수(Binary Numbers) 1.1.1.1 들어가며 워크쉬트를 나눠주기 전에, 전체 그룹에게 기본원리에 대해서 시범을 보여주는 것이 도움이 된다. 본 활동에서 아래와 같은 5장 카드 한 세트가 필요하다. 각각의 카드는 한 면에는 점을 반대면에는 아무것도 없다. 5명의 아이들을 골라서, 교실 앞으로 시범 카드를 나눠준다. 카드의 순서는 반듯이 다음과 같다. 1.1.1.2 토론 카드 위에 점(dot)의 개수에서 무엇을 알아챘나요? (카드 각각은 오른쪽에 있는 카드보다 점의 개수가 2배 많다.) 왼쪽으로 옮긴다면 다음 장의 카드는 점을 몇 개나 가질까요? (32) 그 다음은…… ? 카드를 몇장 뒤집고 앞면만 보이는 카드의 점을 더해서 숫자를 만들 수 있다. 아이들에게 숫자 6을 만들어 보도록 해보세요. (점 4개 카드와 점 2개 카드), 그리고 15를 만들고 (8점, 4점, 2점, 1점 카드), 그리고 21을 만들어 봅시다 (16점, 4점, 1점 &gt; 카드). 이제 영에서부터 순서대로 수를 세어보자. 수업의 나머지 시간은 어떻게 카드가 변화하는지 자세히 살펴볼 필요가 있다. 카드를 뒤집는 방법에 패턴을 볼 수 있다. (각 카드를 뒤집으면 오른쪽 대비 절반이다.) 본 활동을 한 개 이상 그룹에서 확대해보자. 이진수 카드가 보이지 않을 때는 0 으로 표시한다. 이진수 카드가 보이면, 1 로 표시한다. 이것이 이진수 체계다. 01001을 아이들에게 만들어 보게 한다. 01001은 십진수로 무엇일까요? (9) 17은 이진수로 무엇일가요? (10001) 아이들이 개념을 이해할 때까지 몇 번 더 시도해 본다. 학습 강화를 위해 다섯 가지 선택가능한 확장 활동이 있고, 아이들이 할 수 있으면 확장 활동을 가지고 많이 연습할 수 있게 합니다. 1.1.2 워크시트 활동: 이진수(Binary Numbers) 1.1.2.1 계수(counting)하는 방법 배우기 여러분은 어떻게 계수 하는지 이제 안다고 생각합니다. 그런데 다음에 계수하는 새로운 방법이 있다. 컴퓨터가 단지 0 과 1 만을 사용한다는 사실을 알고 있습니까? 컴퓨터에서 보고 듣는 모든 것, 글, 그림, 숫자, 영화, 소리 조차도 단지 숫자 두개로 저장된다. 컴퓨터가 사용하는 정확히 동일한 방법으로 이번 활동을 통해서 비밀 메시지를 친구에게 보내는지를 여러분에게 알려줄 것이다. 1.1.2.2 따라하기 설명 종이에서 카드를 잘라내서 다음에 보여지듯이 왼쪽에 점 16개가 있는 카드부터 순서대로 차례로 놓으세요. 카드가 정확하게 동일한 순서로 놓여있는지를 확인하세요. 정확하게 점 5개가 보여지도록 카드를 뒤집으세요. 카드는 동일한 순서로 놓여져야 합니다. 3, 12, 19를 어떻게 만드는지 알아보자. 이들 숫자를 만들기 위한 하나 이상의 방법이 있을까요? 만들 수 있는 가장 큰 수는 무얼까요? 가장 작은 숫자는 무엇일까요? 가장 큰 수와 가장 작은 수 중에 만들 수 없는 숫자가 있나요? 응용문제: 1,2,3,4 숫자를 순서대로 만드세요. 숫자를 하나씩 증가시키기 위해 카드를 뒤집는 논리적인 믿을만한 방법을 찾을 수 있나요? 1.1.2.3 복사 마스터: 이진수 1.1.2.4 워크시트 활동: 이진수 계산 이진수 체계는 카드가 앞면인지 뒷면인지를 표현하는데 0과 1을 사용한다. 0은 카드 뒷면, 1은 점을 볼 수 있는 윗면이다. 예를 들어, 10101 이 무엇인지 풀 수 있나요? 11111 은 무엇일까요? 몇월 몇일 태어났나요? 이진수로 적어보세요. 친구 생일을 이진수로 무엇인지 알아보세요. 1.1.2.5 아래 기호를 숫자로 풀어보세요: 응용문제: 1,2,4,8,16 길이를 가진 줄(rope) 세트를 사용하여 31 단위까지 어떤 길이도 나타낼 수 있다는 것을 보여주세요. 서류가방이나 상자 같은 무거운 물건의 무게를 재기 위해서 균형저울과 무게추 몇개를 가지고 어떻게 무게를 잴 수 있는지 보이고 어른들을 놀래주세요. 1.1.3 워크시트 활동: 비밀 메시지 보내기 정훈이가 땡돌 땡돌 놀다가 그만 백화점 최고층에 갇혔다. 크리스마스 전날이고 선물을 가지고 무사히 집에 가고 싶었다. 정훈이는 무엇을 할 수 있을까? 전화도 시도해보고, 소리도 질러봤으나 주변에는 아무도 없었다. 길거리 반대편에 어떤 사람이 밤 늦도록 컴퓨터로 작업하고 있는 것을 봤다. 어떻게 그 사람의 관심을 끌 수 있을까? 정훈이는 주위를 둘러보고 할 수 있는 것을 찾아봤다. 그리고, 놀라운 아이디어가 떠올랐다—그녀에게 메시지를 보내기 위해서 크리스마스 트리의 전구를 사용하는 것이다. 주변의 전구를 모두 찾아 연결해서 전구를 켜거나 끌 수 있었다. 간단한 이진코드를 사용하는데 길 건너 여성분이 이진수를 이해한다고 확신했기 때문이다. 여러분도 할 수 있겠습니까? 1.1.4 워크시트 활동: 전자우편과 모뎀 {binary-number-modem} 모뎀으로 인터넷에 연결된 컴퓨터는 메시지를 보내기 위해서 이진수 체계를 사용합니다. 유일한 차이점은 비프음(beep)을 사용하는 것이다. 높은 비프음은 1, 낮은 비프음은 0이다. 이런 음조(tone)는 엄청 빨리 날아간다. 너무나 빨라서 우리가 듣게 되는 것은 끔찍하게 연속된 끼익 소리다. 만약 들은 적이 없다면, 인터넷에 연결된 모뎀소리에 귀 기울여 들어보세요. 혹은 팩시밀리의 신호음을 들어보세요—정보를 보내기 위해서 팩시밀리 기계도 모뎀을 사용합니다. 정훈이가 백화점에서 사용한 동일 신호를 사용해서, 친구에게 전자우편을 보내보세요. 친구와 여러분 모두 편안하게 해보세요—여러분이 모뎀처럼 빠를 필요는 없어요. 1.1.4.1 워크시트 활동: 31보다 큰 수 세기 이진 카드를 다시 보세요. 다음 카드를 나열된 순서(sequence)에서 만들려면, 얼마나 많은 점이 필요할까요? 그 다음 카드는 얼마나 많은 점이 필요할까요? 새로운 카드를 만들 때마다 여러분이 지켜야 하는 규칙은 무엇일까요? 보시다시피, 다음 큰 숫자를 만들기 위해서 단지 몇 장의 카드만 필요합니다. 주의 깊이 순서(sequence)를 살펴보면, 매우 흥미로운 관계를 발견하실 수 있습니다. 1.1.4.2 1, 2, 4, 8, 16, … 1, 2, 4를 더하면 1 + 2 + 4 = ? 얼마일까요? 1, 2, 4, 8을 더하면 1 + 2 + 4 + 8 = ? 처음부터 이들 숫자를 다 더하면 무슨 일이 생길까요? “손가락을 걷게 한다”(‘’let your fingers do the walking’’?)는 표현을 들어봤나요? 손가락으로 계수를 하지만 10이상 셀 수는 없어요— 외계인이 될 필요는 없어요. 이진수 체계를 사용하고 손가락 각자가 카드를 나타낸다면 0에서31가지 셀 수 있어요. 즉 32개 숫자가 됩니다. (0도 숫자라는 것을 잊지 마세요.) 손가락을 사용해서 순서대로 수를 세보세요. 손가락을 치켜 세우면, 1을 나타내고, 손가락을 내리면 0을 나타냅니다. 만약 양쪽 손 모두 사용하면 0~1023까지 셀 수 있어요. 즉, 1024개의 숫자입니다. 여러분이 만약 잘 구부릴 수 있는 발가락을 가지고 있으면(이번에는 외계인이 되셔야 합니다.^^;) 더 많은 숫자를 셀 수 있어요. 한쪽 손이 32까지 셀 수 있고, 두 손으로 32*32=1024까지 셀 수 있어요. 플렉시양(Miss Flexi)의 발가락으로는 얼마나 큰 수를 셀 수 있나요? 1.1.5 워크시트 활동: 이진수 더 알아보기 이진수의 또 다른 흥미로운 특성은 0이 오른쪽 끝에 붙게 될 때 생긴다. 십진수의 경우, 0을 오른쪽 끝에 붙이게 되면 10을 곱한 결과가 된다. 예를 들어 9에 0을 &gt; 붙이면 90이 되고, 30은 300이 된다. 하지만, 이진수의 오른쪽 끝에 0을 붙이면 무슨 일이 벌어질까? 다음을 시도해 보세요. 가설을 검증하기 위해 다른 것도 만들어 시도해 보세요. 무슨 규칙이 있을까요? 왜 이렇게 될까요? 지금까지 우리가 사용한 각 카드는 컴퓨터의 비트(bit)를 나타냅니다. (’bit’는 ‘binary digit’의 약자입니다.) 그래서 지금까지 여러분이 사용한 알파벳 &gt; 기호는 단지 5개의 카드, 즉 비트를 사용해서 나타냈습니다. 하지만, 컴퓨터는 문자가 대문자인지 소문자인지를 알아야 하고 또한 자릿수, 구두점, $, ~ 같은 특수문자를 &gt; 인지해야 합니다. 직접 눈으로 키보드를 살펴보고 컴퓨터가 얼마나 많은 문자를 표현해야 하는지를 살펴보세요. 모든 문자를 저장하기 위해서 컴퓨터는 얼마나 많은 비트를 필요로 할까요? 대부분의 컴퓨터는 아스키(ASCII, American Standard Code for Information Interchange, 정보교환 미국 표준 코드체계) 코드를 사용합니다. 아스키는 문자마다 별도의 비트를 사용하는 것을 기준으로 하고 있지만 비영어권 국가에서는 더 많은 코드를 사용합니다. 1.1.5.1 컴퓨터 과학 핵심 개념 {binary-number-lesson} 오늘날 컴퓨터는 정보를 표현하기 위해서 이진수 체계를 사용합니다. 단지 숫자가 두개만 사용되기 때문에 이진수 체계라고 불립니다. &gt; 사람은 일반적으로 십진법(base 10)을 사용한데 반해 이진법(base 2)으로 알려져 있습니다. 0 과 1 각각은 비트(bit, binary digit)로 불립니다. 비트는 컴퓨터 &gt; 주기억장치에 스위치가 온오프 상태의 트랜지스터나 충방전된 캐패시터로 표현됩니다. 전화선이나 무선 라디오를 통해서 데이터가 전송될 때, 고음과 저음 음조(tone)가 1과 0을 표현하기 위해서 사용됩니다. 자기 디스크(하드디스크나 플로피 디스크)나 테이프에서는 비트가 코팅된 표면에 자기력장 방향(북-남, 남-북)으로 표현됩니다. 오디오 CD, CD-ROM, DVD는 광학적으로 비트를 저장합니다. 비트 정보를 저장하는 표면은 빛을 반사하거나 하지 않습니다. 한 비트 자체는 많은 정보를 담을 수 없어 0~255까지 숫자를 표현할 수 있는 8개를 그룹으로 묶습니다. 비트 8개를 그룹으로 묶어 바이트(byte)라고 합니다. 컴퓨터 속도는 한번에 처리하는 비트의 숫자에 달려있다. 예를 들어, 32비트 컴퓨터는 한번의 연산으로 32비트의 숫자를 처리할 수 있고 16비트 컴퓨터는 32비트 숫자를 작은 조각으로 쪼개서 처리하게 되어 속도가 느리다. 궁극적으로 비트와 바이트는 컴퓨터가 숫자, 텍스트, 다른 종류의 정보를 저장하고 전송하기 위해서 사용하는 것이다. 앞으로 몇몇 활동에서 다른 종류의 정보를 어떻게 &gt; 컴퓨터에서 표현되는지 학습하게 될 것입니다. 1.1.5.2 해답과 힌트 {binary-number-solution} 1.1.5.2.1 이진수 3 은 카드 2, 1 12 는 카드 8, 4 19 는 카드 16, 2, 1 어떤 숫자를 만들기 위해서 단 하나의 방법만 있다. 만들 수 있는 가장 큰 수는 31. 가장 작은 숫자는 0. 그 사이 모든 숫자를 만들 수 있고, 각 숫자를 표현하는 방법은 유일하다. 응용문제: 하나씩 숫자를 증가시키려면, 모든 카드가 윗면이 될 때까지 오른쪽부터 왼쪽까지 모든 카드를 뒤집는 것이다. 1.1.5.2.2 이진수 계산 10101 = 21, 11111 = 31 1.1.5.2.3 비밀 메시지 보내기 해독된 메시지: HELP IM TRAPPED 1.1.5.2.4 31보다 큰 수 세기 처음부터 숫자를 더한다면, 합계는 항상 급수열의 다음 숫자보다 1 이 작은 수가 된다. 플레시 양의 발가락은 1024 × 1024 = 1,048,576, 즉 0 부터 1,048,575 까지 1.1.5.2.5 이진수 더 알아보기 오른쪽 끝에 0을 놓게 되면, 숫자는 항상 배수가 된다. 1을 포함하는 모든 장소는 이전 값의 배수가 된다. 그래서 총수는 배수가 된다. (10진수의 경우 0을 오른쪽 끝에 놓게 되면 10을 곱한 결과가 된다.) 컴퓨터는 모든 문자를 저장하기 위해서 7 비트가 필요하다. 128 문자까지 가능하다. 일반적으로 1 바이트 8비트에 7 비트가 저장되고 1 비트는 버려진다. 1.2 숫자로 색깔 표현하기 - 이미지 표현 1.2 개요 컴퓨터는 습작물, 사진, 그림을 저장하는데 단지 숫자만을 사용한다. 다음의 활동은 컴퓨터가 어떻게 이러한 작업을 하는지를 보여준다. 1.2 교과학습 연계 수학: 기하학 레벨 2 이상. 모양과 공간 탐색. 1.2 기술 계수 (Counting) 도식화 (Graphing): 평면을 사각형의 격자로 잘게 나누어 채색하여 그림으로 &gt; 표현 1.2 나이 7세 이상 1.2 학습 교재 OHP 마스터에서 복사한 OHP 시트: 숫자로 색깔 표현하기 아이마다 필요한 것 – 워크시트 활동: 어린이 팩스 – 워크시트 활동: 자신만의 사진 만들기 1.2.1 언플러그드 활동 동영상 한글 동영상 영어 동영상 애타게 찾고 있습니다. 1.2.2 숫자로 색깔 표현하기 1.2.2.1 들어가며 1.2.2.2 토의 질문 팩시밀리 기계(팩스, fax)는 무슨 일을 하나요? 컴퓨터가 어떤 상황에서 그림을 저장할 필요가 있나요? (그림을 그리는 프로그램, 그래픽 게임, 멀티미디어 시스템) 컴퓨터는 숫자만 사용할 수 있는데 어떻게 그림을 저장할까요? (학습 활동을 위해서 아이들이 팩시밀리를 사용하여 메시지를 주고 받게 준비하는 것도 좋습니다.) 1.2.2.3 OHP 시트를 사용한 시연 컴퓨터 화면(computer screen)은 픽셀(pixels, picture elements)로 &gt; 불리는 작은 점들의 격자로 나눠져 다. 흑백 그림에서 각 픽셀은 검은색이거나 하얀색이 된다. 문자 “a”를 확대해서 픽셀을 살펴보자. 컴퓨터가 그림을 저장할 때, 필요한 전부는 어느 점이 검은색이고, 어느 점이 &gt; 흰색인가하는 정보다. 위 그림은 문자 “a” 그림이 어떻게 숫자로 표현되는지를 보여준다. 첫 번째 줄은 &gt; 하얀 픽셀 하나, 검은 픽셀 세 개, 시 하얀 픽셀 하나다. 그래서 첫 줄은 &gt; 1,3,1로 표현된다. 첫 번째 숫자는 항상 하얀 픽셀과 관계된다. 만약 첫 번째 픽셀이 검정색이면, 첫 &gt; 번째 줄은 0으로 시작한다. 17 쪽의 연습문제에는 방금 전에 보여준 방법을 활용하여 아이들이 복호화(decode)&gt; 할 그림이 있습니다. 1.2.2.4 복사 마스터: 숫자로 색깔 표현하기 &lt; 컴퓨터 화면에 보이는 “a” 문자. 문자 이미지“a”를 픽셀이 보이도록 확대한 뷰(view) &gt; &lt; “동일한 이미지를 숫자 코드(code)로 표현한 것” &gt; &lt; “공백 격자 그리드(grid) (교수 목적 제공)” &gt; 1.2.3 워크시트 활동: 어린이 팩시밀리 첫 번째 그림이 가장 쉽고, 마지막 그림이 가장 복잡하다. 실수하기 쉬워서 색칠할 연필과 지우개를 사용하기를 권한다. 1.2.4 워크시트 활동: 자신만의 그림을 그리자 이제 숫자가 그림을 어떻게 표현하는지를 배웠습니다. 친구를 위해서 여러분이 직접 그림을 만들어 보세요. 위쪽 격자 그리드에 그림을 그리고, 다 그렸으면 아래쪽 격자 그리드 옆에 숫자로 코드를 적으세요. 점선을 따라서 자르고, 아래쪽 격자 그리드를 친구가 색칠하도록 전달해 주세요. (노트: 원치 않으면 전체 격자 그리드를 모두 사용하지 않아도 됩니다. 그림이 격자 전체를 차지하지 않는다면, 아래 몇몇 줄을 공백 상태로 두세요.) 아래를 절취하세요 1.2.5 워크시트 활동: 자신만의 그림을 그리자 (심화문제) 심화문제: 채색된 이미지를 표현하려면, 색깔을 표현하는 숫자를 사용한다. (예, 0 은 검정, 1 은 빨강, 2 는 녹색 등) 두 숫자로 픽셀을 표시한다: 첫 번째 숫자는 전에 표기한 것과 같고 두 번째 숫자가 색깔을 표시한다. 친구를 위해 색깔 그림을 만들어 보세요. 각 숫자가 무슨 색깔을 의미하는지를 사전에 친구에게 알려주는 것을 잊지 마세요. 아래를 절취하세요 1.2.5.1 변형과 확장 격자 위에 종이에 그려보세요. 최종 이미지를 격자 그리드 없이 볼 수 있게 해보세요. 이미지가 훨씬 더 선명해 니다. 격자 그리드에 색깔을 칠하는 대신에 좀더 커다란 격자 그리드 위에 아이들이 사각형 스티커 종이를 사용하거나 체를 놓을 수도 있어요. 1.2.5.2 토의 점 길이가 이진수로 표현되기 때문에, 픽셀 길이에 제한이 있는 것이 보통입니다. 만약 7 까지만 숫자를 사용할 수 있는데, 어떻게 12 개 검정 픽셀을 표현할 수 있을까요? (좋은 방법은 일련의 7 개 검정 픽셀, 0 개 하얀색 픽셀, 그리고 일련의 5개 검정 픽셀로 표현하는 것입니다.) 1.2.6 컴퓨터 과학 핵심 개념 팩시밀리 기계는 흑백 종이를 약 1000 × 2000 픽셀로 스캔해서 모뎀을 사용하여 다른 팩시밀리 기계에 보내는 정말 단순한 컴퓨터다. 다른 팩시밀리 기계는 전송 받은 픽셀을 종이에 출력한다. 종종, 팩스 이미지가 넓은 흰 공백(예, 한계(margin)) 혹은 검은 픽셀 (예, 가로줄)을 가지고 있다. 색깔 있는 그림은 훨씬 더 많은 중복이 있다. 이런 이미지를 저장하려고 필요한 많은 저장공간을 절약하기 위해서, 프로그래머는 다양한 압축 기술을 사용한다. 여기서 사용되는 방법은 “런 길이 부호화(run-length coding)”로 불리고, 이미지를 압축하는 효과적인 방법이다. 이미지를 압축하지 않으면, 사진을 보내는데 오랜 시간이 걸리고 추가로 더 많은 저장공간이 필요하다. 따라서, 웹페이지에 사진을 게시하거나 팩스를 보내는 것이 가능하지 않을 수 있다. 예를 들어, 팩스 이미지는 일반적으로 원본 크기의 7 분의 1 로 압축된다. 압축 없이 전송하는데는 7 배 많은 시간이 걸린다. 사진과 그림은 다양한 압축기법을 사용하여 원본의 10분의 1, 혹은 100분의 1의 크기로 압축된다. 이렇게 압축해서 더 많은 이미지를 동일한 디스크에 저장할 수 있고, 인터넷을 통해서 사진과 그림을 보는데 짧은 시간내에 볼 수 있다는 의미가 된다. 프로그래머는 적절한 압축 기법을 선택해서 이미지를 전송할 수 있다. 1.2.7 해답과 힌트 1.2.7.1 어린이 팩시밀리 워크시트 정답 1.3 다시 말할 수 있어요! - 텍스트 압축 1.3 개요 컴퓨터가 정보를 저장하기 위한 공간에는 한계가 있어서, 가능하면 효율적으로 정보를 표현할 필요가 있다. 이 방법을 “압축”(compression)이라고 한다. 저장하기 전에 데이터를 부호화(coding)하고 정보를 끌어낼 때는 복호화(decoding)해서, 컴퓨터에 더 많은 데이터를 저장하고 인터넷을 통해서 더 빨리 보낼 수 있게 한다. 1.3 교과학습 연계 영어: 단어와 텍스트 패턴 인식 기술: 기술 지식과 이해. 컴퓨터 작동원리 1.3 기술 글로 쓴 텍스트 복사 1.3 나이 9세 이상 1.3 학습 교재 OHP 마스터에서 복사한 OHP 시트: 다시 말할 수 있어요! 아이마다 필요한 것 – 워크시트 활동: 다시 말하기! – 워크시트 활동: 심화 문제 – 워크시트 활동: 짧고 간결하게 – 워크시트 활동: 심화 문제 (상급자) 1.3.1 언플러그드 활동 동영상 EBS 링크 동영상 영어 동영상 1.3.2 다시 말할 수 있어요! 1.3.2.1 들어가며 컴퓨터는 많은 데이터를 저장하고 전송해야 합니다. 그래서 너무 많은 저장 공간을 사용하거나, 네트워크를 통해 정보를 보내는데 시간이 오래 걸리면 안돼서, 텍스트를 다음과 같이 압축합니다. 1.3.2.2 시연 및 토론 “비(rain)” OHP 로 보여주세요. 다음 시(poem)에서 문자 패턴을 찾아보세요. 반복되는 2 개 이상의 문자, 단어, 문구를 찾을 수 있나요? (아래 도식에서처럼 박스를 채워넣으세요, 참고. pitter patter 타닥타닥 소리) 1.3.2.2 복사 마스터: 다시 말할 수 있어요! Rain: 비 pitter patter: 빗소리 Listen to:귀 기울여 듣다 window pane: 창유리 1.3.2.2 복사 마스터: 다시 말할 수 있어요! 다음 시에서 많은 단어와 글자가 빠져있습니다. 여러분이 빠진 단어와 글자를 채워 넣어 온전한 시가 될 수 있도록 만들어 주세요. 화살표가 가리키는 박스에서 채워 넣을 단어와 글자를 찾을 수 있습니다. 이제 간단한 시나 동요를 골라서 여러분 자신만의 퍼즐을 만들어보세요. 여러분이 만든 화살표가 항상 이전 텍스트 부분을 가리키는지를 꼭 확인하세요. 우리가 읽는 동일한 방식으로 여러분의 시는 왼쪽에서 오른쪽으로 위에서 아래로 복호화할 수 있어야 합니다. 1.3.2.2 도전문제 : 여러분이 얼마나 적은 단어를 필요로 하는지 살펴보세요. 제안: “Three Blind Mice”, “Mary Mary Quite Contrary”, “Hickory Dickory Dock” 혹은 Dr Seuss 책도 시도해 보세요. 힌트: 너무나 많은 화살표를 피하세요. 글을 써가면서, 글자와 단어 주변에 많은 공백을 둬서 박스 내부와 이를 가리키는 화살표 사이에 박스를 위한 공간을 확보하세요. 시를 먼저 쓰고 나서 박스를 어디에 위치할지를 결정한다면 퍼즐 설계가 훨씬 쉬워요. 1.3.3 워크시트 활동: 심화 문제 이 퍼즐을 어떻게 풀 수 있나요? 가끔 빠진 텍스트가 자기 자신의 일부를 가리킵니다. 이런 경우 글자가 왼쪽부터 오른쪽으로 복사된다면 올바르게 복호화됩니다. 필요하기 전에 각 문자가 복사되어 사용가능해집니다. 특별히 긴 순서의 문자나 패턴있다면, 컴퓨터에서 유용합니다. 여러분 자신만의 그림을 몇개 그려보세요. 컴퓨터에 박스와 화살표는 숫자로 나타납니다. 예를 들어, Banana Ban(2,3)로 쓰여집니다. 복사를 위해서 “2”는 시작점으로 처음에서 2 글자 다음에서 시작한다는 의미가 된다. Ban_ _ _ “3”은 연속된 3 개 문자 복사를 뜻합니다. Ban_ _ Banan_ Banana 숫자 두 개가 단어를 복호화하는데 사용되었는데, 대체로 둘 혹은 이상의 문자 그룹만을 사용할 때 압축에 효과가 있습니다. 그렇지 않은 경우 공간이 절약되지 못합니다. 사실, 숫자 두개를 사용하여 한 문자를 부호화한다면 파일 크기는 올라갈 수 있어요. 컴퓨터가 압축하는 방식과 동일하게 자신만의 단어 몇개를 만드세요. 여러분의 친구가 복호화할 수 있을까요? 1.3.4 워크시트 활동: 짧고 간결하게 1.3.4.1 여러분은 여기에서 얼마나 많은 단어를 필요로 하나요? 여러분 자신을 가능한 많은 정보를 디스크에 저장하려고 하는 컴퓨터라고 가정해봅시다. 이미 앞에서 나온 두개 이상의 문자 그룹을 선을 그어 지우세요. 포인터로 대체될테니 이들은 더 이상 필요하지 않아요. 목적은 가능한 많은 문자를 줄을 그어 지우는 것입니다. I know an old lady who swallowed a bird How absurd! She swallowed a bird! She swallowed the bird to catch the spider That wriggled and jiggled and tickled inside her She swallowed the spider to catch the fly I don’t know why she swallowed a fly Perhaps she’ll die… 1.3.5 워크시트 활동: 심화 문제 (상급자) {text-compression-worksheet-advanced} 1.3.5.1 정말로 어려운 압축에 도전할 준비가 되셨나요? 아래 이야기에 대해 컴퓨터 프로그램을 실행하여 1,633 문자가 줄을 그어 지워질 수 있다는 것을 확인했다. 여러분은 얼마나 많이 찾아 지울 수 있나요? 단지, 두개 이상의 반복되는 문자만을 줄을 그어 제거할 수 있다는 것을 기억하세요. 행운을 빕니다. Once upon a time, long, long ago, three little pigs set out to make their fortunes. The first little pig wasn’t very clever, and decided to build his house out &gt; of straw, because it was cheap. The second little pig wasn’t very clever either, and decided to build his house out of sticks, for the “natural” look that was &gt; so very much in fashion, even in those days. The third little pig was much smarter than his two brothers, and bought a load of bricks in a nearby town, with which &gt; to construct a sturdy but comfortable country home. Not long after his housewarming party, the first little pig was curled up in a chair reading a book, when there came a knock at the door. It was the big bad wolf, &gt; naturally. “Little pig, little pig, let me come in!” cried the wolf. “Not by the hair on my chinny-chin-chin!” squealed the first little pig. “Then I’ll huff, and I’ll puff, and I’ll blow your house down!” roared the wolf, and he did huff, and he did puff, and the house soon collapsed. The first &gt; little pig ran as fast as he could to the house of sticks, and was soon safe inside. But it wasn’t long before the wolf came calling again. “Little pig, little pig, let me come in!” cried the wolf. “Not by the hair on my chinny-chin-chin!” squealed the second little pig. “Then I’ll huff, and I’ll puff, and I’ll blow your house down!” roared the wolf, and he did huff, and he did puff, and the house was soon so much firewood. &gt; The two terrified little pigs ran all the way to their brother’s brick house, but the wolf was hot on their heels, and soon he was on the doorstep. “Little pig, little pig, let me come in!” cried the wolf. “Not by the hair on my chinny-chin-chin!” squealed the third little pig. “Then I’ll huff, and I’ll puff, and I’ll blow your house down!” roared the wolf, and he huffed, and he puffed, and he huffed some more, but of course, the &gt; house was built of brick, and the wolf was soon out of breath. Then he had an idea. The chimney! He clambered up a handy oak tree onto the roof, only to find that &gt; there was no chimney, because the third little pig, being conscious of the environment, had installed electric heating. In his frustration, the wolf slipped and &gt; fell off the roof, breaking his left leg, and severely injuring his pride. As he limped away, the pigs laughed, and remarked how much more sensible it was to live &gt; in the city, where the only wolves were in the zoo. And so that is what they did, and of course they all lived happily ever after. 1.3.6 컴퓨터 과학 핵심 개념 컴퓨터 저장용량은 믿기 힘든 속도로 빠르게 늘어나고 있다. 지난 25년간 일반인들이 사용하는 컴퓨터 저장용량은 백만 배 늘어났다. 하지만, 컴퓨터에 저장할 더 많은 것이 있다. 컴퓨터는 책 전체를 저장할 수 있고, 심지어 도서관의 모든 책, 음악, 영화도 저장공간만 허락된다면 저장할 수 있다. 큰 파일은 다운로드 하는데 긴 시간이 걸려서 인터넷에서도 골치거리다. 또한, 컴퓨터를 점점 더 소형화 하여 스마트폰과 스마트워치에 좀더 많은 정보가 저장되길 기대한다. 하지만, 이 문제에 해결책은 있다. 더 많은 저장 공간이나 더 빠른 네트워크를 구축하는 대신에, 데이터를 *압축해서** 적은 공간을 차지하도록 할 수 있다. 데이터를 압축하고 압축을 푸는 과정은 컴퓨터가 자동으로 해준다. 아프로 디스크는 점점 더 많은 정보를 저장하게 되고, 웹페이지는 더 빨리 화면에 정보를 뿌려주지만, 실제로 컴퓨터가 더 많은 연산처리를 한다는 것에 주목해야 한다. 많은 압축기법이 발명되었다. 이 활동에 사용된 방법이면서, 먼저 출현한 텍스트를 가리키는 원칙을 가진 압축기법은 1970년대 두명의 이스라엘 교수님이 발명하신 ‘Ziv-&gt; Lempel coding,’ 줄여서 ‘LZ coding’ 이라고 한다. 이 방법은 어떤 언어에도 사용될 수 있는 범용성이 있고, 쉽게 데이터 크기를 반으로 압축할 수도 있다. 개인용 컴퓨터의 zip 파일을 지칭하기도 하고, GIF 이미지, 초고속 모뎀에도 사용된다. 모뎀의 경우 전화선을 통해서 전송에 필요한 데이터 양을 줄여 더 빨리 데이터가 &gt; 전송이 되도록 한다. 더 많이 출현하는 문자가 다른 것보다 짧은 부호를 가져야 한다는 아이디어에 기초한 다른 방법도 있다. 모스 부호(Morse code)가 이러한 아이디어를 차용했다. 1.3.7 해답과 힌트 1.3.7.1 다시 말할 수 있어요! (복사 마스터) 1.3.7.2 다시 말할 수 있어요! Pease porridge hot, Pease porridge cold, Pease porridge in the pot, Nine days old. Some like it hot, Some like it cold, Some like it in the pot, Nine days old. 1.4 카드 뒤집기 마술 - 오류 탐지 및 수정 1.4 개요 데이터가 컴퓨터 디스크에 저장되거나 A 컴퓨터에서 B 컴퓨터로 데이터가 전송될 때, 보통 데이터처리할 때 변경될 것이라고 생각하지는 않는다. 하지만 때때로 데이터에 오류가 발생하고, 우연히 데이터 변경이 일어나기도 한다. 이번 활동은 마술을 사용해서 손상된 데이터를 어떻게 탐지하고 오류난 데이터를 어떻게 교정하는지 익힐 것입니다. 1.4 교과학습 연계 수학: 정수론 레벨 3 이상. 연산과 추정 탐색 대수 레벨 3 이상. 패턴과 관계 탐색 1.4 기술 계수 (counting) 짝수와 홀수 인식 1.4 나이 9세 이상 1.4 학습 교재 한쪽 면만 색칠된 냉장고 자석 36개 한 벌 시연을 위해서 자석이 붙을 수 있는 금속판 (화이트보드 추천) 아이 한 쌍이 필요한 것 한쪽 면만 색칠된 똑같은 카드 36개 1.4 언플러그드 활동 동영상 EBS 링크 동영상 영어 동영상 1.4.1 마술 1.4.1.1 시연 마술사가 될 기회가 있어요. 동일한 양면 카드가 필요합니다. (한쪽 면만 색칠된 커다란 종이를 자르세요) 한쪽 면만 색칠된 평평한 냉장고 자석 카드를 사용하기가 시연 목적으로 좋습니다. 다음과 같이 5 × 5 정사각형에 임의로 앞뒤가 뒤섞인 카드를 놓을 어린이를 고르세요. “조금 더 어렵게 만들도록” 추가로 행(row)과 열(column)을 덧붙이세요. 추가되는 카드들이 묘기의 가장 중요한 요소입니다. 추가되는 카드를 골라서 각 행과 열에 짝수 색깔 카드가 될 수 있도록 맞춥니다. 선생님이 눈을 감고 있는 동안 아이에게 카드 하나를 뒤집게 합니다. 바뀐 카드를 가진 행과 열은 이제 홀수개의 색깔 카드를 가지게 되어서 바뀐 카드를 쉽게 찾을 수 &gt; 있습니다. 묘기가 어떻게 수행되었는지 아이들이 추론할 수 있을까요? 1.4.1.2 아이들에게 묘기 설명하기: 둘이 짝이 되어서, 어린이들이 5 × 5 카드를 자리에 놓습니다. 각 행과 열에는 얼마나 많은 색칠된 카드가 있나요? 짝수인가요, 홀수인가요? 기억하세요 0은 짝수입니다. 이제 각 행에 6번째 카드를 추가하는데, 색칠 카드가 항상 짝수가 되도록 합니다. 이 추가 카드를 패리터(parity) 카드라고 합니다. 아래쪽을 따라서 6번째 카드 행을 추가하는데, 각 열의 색칠 카드의 수가 짝수가 되도록 합니다. 이제 카드를 한 장 뒤집습니다. 행과 열에서 무엇을 눈치채셨습니까? (색칠 카드의 수가 홀수가 됩니다.) 패리티 카드는 언제 오류가 발생했는지를 보여주기 위해 &gt; 사용됩니다. 이제 순서를 바꿔서 ‘묘기’를 부려봅시다. 1.4.1.3 확장 활동 다른 물체를 사용해 봅시다. 두 개의 상태를 가진 어떤 것도 무방합니다. 예를 들어, 가지고 노는 카드, 동전(앞뒷면), 이진수 체계와 연관되도록 과 0과 1로 인쇄된 &gt; 카드도 됩니다. 만약 두개 혹은 그 이상의 카드가 뒤집어진다면 무슨 일이 생길까요? (어떤 것이 변경되었다는 것을 말할 수 있지만, 정확하게 어느 두 장의 카드가 뒤집혔는지를 꼭 &gt; 집어서 말하는 것은 항상 가능하지는 않습니다. 통상 두 짝의 카드 중에 하나로 범위를 좁힐 수 있습니다. 4장이 뒤집히는 경우, 나중의 모든 패리티 비트가 정상일 수 &gt; 있어서 오류가 탐지되지 않고 그냥 지나칠 수 있습니다.) 다른 흥미로운 카드놀이 연습은 오른쪽 아래 카드를 생각해 보는 것이다. 위쪽 열에 대해서 올바른 것을 고른다면, 왼쪽 행에 대해서도 그럴까요? (답은 항상 그렇다 &gt; 입니다.) 이 카드놀이 연습에서는 짝수 색칠 카드를 사용하여 짝수 패리티(even parity)를 사용했다. 홀수 패리티(odd parity)로도 할 수 있을까? (가능하지만, 만약 행과 열의 &gt; 숫자가 모두 짝수이거나 홀수이면, 오른쪽 아래 카드는 행과 열에 대해서 같다. 예를 들어, 5 × 9 나 4 × 6 배치는 작동하지만, 3 × 4 배치는 작동하지 않는다.) 1.4.2 오류 검사의 실사례 — ISBN 코드 동일한 검증 기법이 책코드에도 사용된다. 출판된 책은 책 뒷면에 10 자리 코드가 있다. 10 번째 자릿수는 검증 자리수로 카드놀이 연습에서 살펴본 패리티 비트(parity bit) 같은 것이다. ISBN (International Standard Book Number)을 사용한 책을 주문한다면, 출판사는 오류가 있는지 점검을 한다는 의미가 됩니다. 출판사는 간단히 체크썸(checksum)을 살펴볼 것입니다. 이와 같은 방식으로 여러분은 잘못된 책을 기다리다 끝나지 않게 됩니다. 다음에 체크썸을 해결하는 방법이 있습니다. 첫째 자리는 10 을, 둘째 자리는 9 를, 셋째 자리는 8 을, 계속해서 내려가서, 아홉번째 자리는 2 를 곱한다. 그리고는 이들 각 값을 하나이 값으로 합친다. 예를 들어, ISBN 0-13-911991-4 는 다음과 같다. (0 × 10) + (1 × 9) + (3 × 8) + (9 × 7) + (1 × 6) + (1 × 5) + (9 × 4) + (9 × 3) + (1 × 2) = 172 그리고 이 값을 11 로 나눈다. 나머지는 무엇일까? 172 ÷ 11 = 몫 15 나머지 7 만약 나머지가 0 이면, 체크썸은 0 이다. 그렇지 않은 경우 11 에서 나머지를 빼서 체크썸을 얻는다. 11 – 7 = 4 다시 돌아가서, 이 숫자가 ISBN 의 마지막 숫자인가? 예 맞습니다. ISBN 의 마지막 숫자가 4 가 아니라면, 뭔가 잘못된 것을 알 수 있다. 10 을 체크썸 값으로 가지는 것도 가능하다. 이 경우 한 자릿수를 추가로 필요로 한다. 이것이 생겼을 경우, X 문자가 사용된다. 검증 자릿수를 사용하는 또 다른 사례는 식료 잡화품에 붙어있는 바코드(bar code)다. 바코드는 다른 공식을 사용한다. 만약 바코드가 잘못 읽힌다면, 마지막 자릿수는 계산된 값과 달라야 한다. 이런 경우가 발생하면, 스캐너는 삑 소리를 내고, 계산원은 바코드를 다시 스캔한다. 1.4.3 항상 체크썸은 맞을까? 때때로 오류가 생깁니다. 흔한 오류는 다음과 같습니다. 숫자의 값이 변합니다. 두 인접한 숫자가 서로 뒤바뀝니다. 숫자가 중간에 삽입됩니다. 숫자가 빠져버립니다. 체크썸 10 자리 문자 X 가 표기된 책을 찾을 수 있나요? 발견하기 어렵지 않을 것입니다. 모두 11 자리 중에 1 자리는 X 를 가져야 하기 때문입니다. 탐지하기 어려운 오류는 어떤 것이 있을까요? 체크썸 값을 바꾸지 않고 숫자를 바꿀 수 있나요? 두 숫자가 바뀐다면 어떨까요? (흔한 컴퓨터 타이핑 오류) 1.4.4 컴퓨터 과학 핵심 개념 10 달러 현찰을 은행에 예금한다고 가정해 봅시다. 은행 창구 직원이 예치금을 컴퓨터에 타이핑하면 입력된 정보는 중앙 컴퓨터로 전송됩니다. 하지만, 예치금이 전송되는 동안에 회선에 장애가 발생했서 10 달러에 대한 코드값이 1,000 달러로 바뀌었다고 생각해 봅시다. 고객인 여러분의 입장에서는 문제가 아니지만, &gt; 분명 은행에게는 심각한 문제입니다. 전송된 데이터에 오류가 있는지 탐지하는 것은 중요합니다. 그래서 정보를 수신하는 컴퓨터는 데이터가 회선에 전자기적 간섭에 의해서 손상되었는지를 검증할 필요가 있습니다. 때때로, 오류도 함께 전송된 경우에는 원본 데이터를 다시 보낼 수도 있습니다. 하지만, 만약 물리적, 열, 자기적 혹은 전기적 방사선에 노출되어 손상된 경우 다시 전송하는 것이 여의치 못한 경우도 있습니다. 만약 저 먼 우주 탐사선으로부터 데이터를 &gt; 전송받았는데 오류가 발생했다고 다시 재전송되기를 기다리는 것은 매우 지루하고 시간이 많이 걸릴 것입니다. (목성이 지구에 가장 가까울 때, 목성으로부터 라디오 신호를 얻는데 30분 가량 걸립니다.) 데이터가 언제 손상됐는지를 인지(오류 탐지, error detection)하고, 원자료를 복원(오류 수정, error correction)할 필요가 있습니다. “카드 뒤집기”에 사용된 동일한 기법이 컴퓨터에도 적용됩니다. 비트를 가상의 행과 열에 놓아, 패리티 비트를 각 행과 열에 추가함으써, 오류가 발생했는지 여부와 어디에서 발생했는지도 탐지할 수 있습니다. 문제 비트는 다시 되돌려, 오류 수정을 수행합니다. 물론, 컴퓨터는 복수의 오류를 탐지 수정할 수 있는 좀더 복잡한 오류 통제시스템을 사용합니다. 컴퓨터 하드디스크는 오류 수정 목적으로 할당된 무척이나 넓은 저장공간을 가지고 있어서 디스크의 일부분이 고장 나더라도 잘 작동될 수 있습니다. 이러한 목적으로 사용되는 시스템은 패리티 방식과 밀접한 관련이 있습니다. 이 활동을 끝난 후에 조크 하나. Q: “Pieces of nine, pieces of nine”(아홉 조각, 아홉 조각)을 무엇이라 할까요? A: 앵무새 오류 (parroty error) 1.4.5 해답과 힌트 1 개 숫자 값이 증가하고, 1 개 숫자 값이 줄어드는 경우에는 총합이 동일하기 때문에 오류가 탐지되지 않습니다. 1.5 질문 20 개 - 정보 이론 1.5 개요 1,000 페이지 책에는 얼마나 많은 정보가 있을까요? 1,000 페이지 전화 번호부에 더 많은 정보가 있을까요? 1,000 페이지 백지에 더 많은 정보가 있을까요? 톨킨이 저작한 “&gt; 반지의 제왕”에 더 많은 정보가 있을까요? 만약 정보의 양을 측정할 수 있다면, 정보를 저장하기 위해 얼마나 많은 저장공간이 필요한지 추정할 수 있습니다. 예를 들어, &gt; 공항에서 비행기에 가방에 단 3개 로마자로 ICN(인천), NRT(나리타), HKG(홍콩) 공항을 상상합니다. 다음 문장을 모음 없이 읽을 수 있습니까? Ths sntnc hs th vwls mssng. 아마도 여러분은 “This sentence has the vowels missing”라고 제대로 읽을 것입니다. 모음에는 그다지 정보가 많지 않기 때문입니다. 이번 활동은 정보의 양을 측정하는 &gt; 방법을 소개합니다. 1.5 교과학습 연계 수학 – 숫자 레벨 3이상. 숫자 탐구: 이상, 이하, 범위 – 대수 레벨 3 이상. 패턴과 관계 탐색 국어: 단어와 문장이 가지는 중복의 유형을 인식하는데 유용함. 1.5 기술 숫자를 비교하고 범위가 정해진 수를 다룬다. 추론한다. 질문한다. 1.5 나이 10세 이상 1.5 학습 교재 처음 활동에는 어떠한 교재도 필요하지 않습니다. 확장활동으로 아이마다 필요한 것 – 워크시트 활동: 의사결정나무 1.5.1 언플러그드 활동 동영상 EBS 링크 동영상 언플러드그 동영상 찾고 있음 1.5.2 질문 20개 1.5.2.1 토론 아이들과 아이들이 생각하는 정보가 무엇인지에 대해서 토론해 봅시다. 책에 정보의 양이 얼마나 되는지 어떻게 측정할 수 있을까요? 페이지 숫자가 중요할까요, 아니면 단어 숫자가 더 중요할까요? 이 책이 다른 책보다 더 많은 정보가 &gt; 있을까요? 책이 몹시 지루한 책이거나, 반대로 특히 재미있는 책이라면 어떨까요? “뭐라, 뭐라, 뭐라(blah, blah, blah)”라는 문구만 포함된 400 페이지 책이 전화번호부보다 &gt; 더 많은 혹은 더 적은 정보를 가지고 있습니까? 컴퓨터 과학자들은 메시지(혹은 책)가 얼마나 놀라운가에 따라 정보량을 측정한다고 설명합니다. 이미 알고 있는 것, 예를 들어 항상 걸어서 학교에 오는 아이가 “오늘은 &gt; 걸어서 학교에 왔다”라고 말했다고 하면 여기에는 정보가 없습니다. 왜냐하면 놀랄 일이 아니기 때문입니다. 하지만 “오늘 헬리콥터 타고 학교에 왔어”라고 했다면, 놀랄 &gt; 것이고, 엄청난 정보를 우리에게 전한 것입니다. 메시지의 ’깜짝도(suprise value)’는 어떻게 측정할까요? 하나의 방법은 정보를 추측하는 것이 얼마나 어려운지를 살펴보는 것이다. 만약 함께 걸어서 학교에 온 친구에게 “오늘 어떻게 학교에 왔는지 맞춰봐”라고 물어보면, 한번에 맞출 수 있습니다. 하지만 과거에 헬리콥터를 타고 온 적이 있으면 여러 번 &gt; 추측할 필요가 있을지도 모르고, 우주선으로 여행을 한 적이 있다면, 더 시간이 걸릴지도 모릅니다. 메시지가 가지는 정보량은 그것을 짐작하는 것이 얼마나 쉬운지 어려운 것인지에 따라 측정합니다. 다음 게임은 이해하는 데 도움을 줄 것입니다. 1.5.3 질문 20개 활동 여기 질문 20개라는 게임을 소개합니다. 정답을 맞출 때까지, 아이들은 선택된 1 명의 아이에게 질문을 계속하고, 선택된 아이는 “예”, “아니오” 둘 중 하나만 대답합니다. &gt; “예” 또는 “아니오”로 대답할 수 있다면 어떤 질문을 해도 좋습니다. 1.5.3.1 질문의 예 다음과 같이 생각하고, 맞춰보세요. - 1에서 100사이의 숫자 하나 - 1에서 1,000사이의 숫자 하나 - 1에서 1,000,000사이의 숫자 하나 - 임의의 정수 - 적당한 그룹으로 패턴을 가진 5개의 숫자 순열. 처음부터 끝까지 순서를 맞춰보세요.(예: 2, 4, 6, 8, 10) 질문 개수를 세어보세요. 질문 횟수를 정보량(value of the “information”)이라고 합니다. 1.5.3.2 후속 토론 어떤 전략으로 질문을 했나요? 가장 효과적인 질문 전략은 무엇이었나요? 1에서 100 사이의 숫자를 찾기 위해서 만약 질문 범위를 절반으로 줄여간다면 단 7번의 질문으로 정답을 맞출 수 있다. 예를 들어, 50보다 작습니까? 예. 25보다 작습니까? 아니요. 37보다 작습니까? 아니요. 43 보다 작습니까? 예. 40 보다 작습니까? 아니요. 41 보다 작습니까? 아니요. 42네요! 예! 흥미로운 점은 질문의 범위가 1,000으로 확대된다면, 10배만큼 노력이 들지 않고, 단지 추가 질문 3개만이 필요하다. 질문의 범위가 두 배씩 증가할 때마다 정답을 찾기 &gt; 위해서 한 개의 추가 질문만을 필요로 합니다. 다음 연계된 후속 활동으로 아이들에게 Mastermind 놀이를 추천드립니다. 1.5.3.3 확장: 메시지에 얼마나 많은 정보가 있을까요? 컴퓨터 과학자는 단순한 숫자 맞추기 게임 말고, 단어나 문장에서 어느 글자가 다음에 가장 나올 것인가 같이 다음 문자를 추측하는 게임도 합니다. 4~6개 단어로 구성된 짧은 문장으로 게임을 진행해 봅시다. 글자를 처음부터 끝까지 잘 정렬된 순서로 질문을 합니다. 왼쪽에서 오른쪽 순서로 문자를 맞춰보세요. 한 아이가 &gt; 글자를 적고, 얼마나 많은 시도 끝에 올바르게 정답을 맞췄는지 횟수를 기록합니다. 예/아니오 답을 가진 질문은 모두 사용될 수 있습니다. 예를 들어, ‘t’가 있나요? &gt; 모음인가요? 알파벳의 m 앞에 오나요? 단어 사이의 공백도 문자로 간주되며 맞춰야 하는 대상이 됩니다. 순서를 바꿔가며 어느 메시지가 찾기 쉬운지 확인해 보세요. 1.5.4 워크시트 활동 : 의사결정나무 질문하는 전략에 대해서 익숙해졌다면, 질문을 하지 않고 메시지를 보낼 수 있다. 다음 도표를 “의사결정 나무”라고 부른다. 이 그림은 0 에서 7 사이 정수를 맞추기 위해 고안된 의사결정 나무 도표입니다. yes가 “예”, no가 “아니오”가 no입니다. 숫자5를 맞추기 위해서 필요한 yes / no 결정은 무엇일까요? 임의 숫자를 맞추기 위해서 yes / no 결정이 몇 번이나 필요할까요? 이제 뭔가 멋진 일을 살펴보시죠. 의사결정나무의 가장 아래 0,1,2,3 …의 숫자 아래에, 이진수를 써 봅시다. (활동 1 참조) 나무를 유심히 살펴보세요. No가 “아니오” 0을, yes가 “예” 1로 나타내면, 무엇이 보이나요? 숫자 추측 게임에서, 질문을 선택하는 하는데 응답 순서가 정확하게 숫자를 &gt; 표현하는 방식과 동일합니다. 0에서 15사이 정수를 맞추기 위한 의사결정 나무를 직접 만들어 봅시다. 심화문제: 누군가의 나이를 맞추려면 어떤 종류의 의사결정 나무를 사용해야 할까요? 문장의 다음 글자를 맞추려면 어떤 의사결정나무가 있어야 할까요? 1.5.5 컴퓨터 과학 핵심 개념 저명한 미국 수학자 (저글러이며, 외발 자전거 선수) 클로드 섀넌(Claude Shannon)은 이 게임으로 많은 실험을 했습니다. 그는 정보량을 비트 (각 “예/아니오” 응답이 0/1 &gt; 비트에 상응)로 측정했습니다. 메시지 정보량은 이미 얼마나 알고 있는냐에 달려있다는 것을 발견했습니다. 때때로 질문 하나로 다른 많은 질문을 할 필요를 없게 만듭니다. 이 경우 메시지의 정보량은 &gt; 매우 적습니다. 예를 들어, 동전던지기 한번의 정보는 통상 1 비트(앞면, 뒷면)입니다. 하지만, 동전의 양면 중 한 면이 편향(bias)되어서 10번 던져 9번 앞면이 나온다면, &gt; 정보량은 더 이상 1 비트가 아니고, 믿든 믿지 않든, 1비트보다 적습니다. 어떻게 동전 던지기 결과를 1 회 미만의 질문으로 알 수 있는 것일까요? 간단합니다. 다음과 같은 &gt; 질문을 하면 됩니다. “다음 2번 동전 던지기 결과 모두 앞면이 나왔나요?” 편향되어 있는 동전 던지기 결과는 이 질문에 약 80% 확률로 “예”, “아니요”가 나온 &gt; 경우에는 두 개의 추가 질문을 해야 합니다. 하지만, 평균적으로, 동전을 던질 때마다 1회 미만의 질문을 할 것이다. 섀논은 메시지 정보량을 엔트로피(“entropy”) 라고 명명했습니다. “엔트로피”는 동전 던지기의 경우는 두 사건(앞면/뒷면)처럼 사건의 수(number) 뿐만 아니라 그것이 &gt; 일어나는 확률(probability)도 영향을 받습니다. 있을 수 없는 사건, 즉 놀라운 정보는 해당 메시지에 대해 많은 횟수의 질문이 필요한데, 이유는 우리가 아직 알지 못하는 &gt; 더 많은 정보를 알려주기 때문입니다. 마치 헬리콥터를 타고 학교에 가는 상황처럼 말입니다. 메시지 엔트로피는 컴퓨터 과학자에게 매우 중요합니다. 엔트로피보다 적은 공간을 차지하도록 메시지를 압축할 수 없습니다. 가장 압축이 좋은 시스템은 숫자 맞추기 게임과 &gt; 동일합니다. 컴퓨터 프로그램이 ’추측’을 하는 것이기 때문에, 질문 목록은 나중에라도 다시 재구성될 수 있다. 그래서 정답(비트)이 저장이 되어 있으면, 정보를 다시 &gt; 재구성할 수 있다! 가장 효율적인 압축 시스템은 텍스트 파일을 원래 크기의 4분의 1 까지 압축할 수 있습니다. 엄청난 저장공간의 절약입니다. 숫자를 추측하는 게임 방법은 사용자가 다음에 무엇을 입력할까를 추측하는 컴퓨터 인터페이스 설계에도 사용됩니다. 키보드 입력에 어려움이 있는 장애인을 위해서 이 &gt; 방법이 유용하게 사용될 수 있습니다. 장애인이 다음에 입력할 것을 컴퓨터가 추측하여 제시하면, 장애인은 원하는 바를 선택하면 됩니다. 좋은 시스템은 평균적으로 문자당 &gt; 2개 예/아니오(yes/no) 결과를 필요합니다. 마우스나 키보드를 미세하게 조정하는데 어려움이 있는 장애인에게 큰 도움이 될 수 있다. 이런 종류의 시스템은 동일한 원리로 &gt; 스마트폰 문자를 입력하는데 사용될 수 있습니다. 1.5.6 해답과 힌트 그 질문이 간단한 “50보다 큽니까?”라는 질문이든 “20과 60 사이입니까?”라는 좀더 복잡한 질문이든지, 1 회 “예/아니오” 질문에 대한 답변은 정확히 1 비트 정보에 &gt; 상응합니다. 숫자를 추측하는 게임에서는 특정 방식으로 질문을 선택해 나아간다면, 응답 순서는 이진수로 표현한 것과 동일합니다. 3은 이진수로 011이고, 의사결정나무에서 응답으로 &gt; 나열하게 되면 “아니오, 예, 예”입니다. “아니오” 대신에 0, “예” 대신에 1을 쓰면, 3을 이진수로 표현한 것과 동일합니다. 나이를 맞히는 의사결정 나무는 작은숫자 쪽으로 편의(bias)가 있을지도 모릅니다. 문장에서 다음 글자의 추천은 앞에 나온 글자에 좌우됩니다. "],
["algorithm.html", "Chapter 2 제 2 부 2.1 전함 - 검색 알고리즘 2.2 가장 가벼운 것과 가장 무거운 것 - 정렬 알고리즘 2.3 시간 내 일을 마치기 - 정렬 네트워크 2.4 진흙도시 프로젝트 - 최소생성나무(Minimal Spanning Trees) 2.5 오렌지 게임 - 네트워크 라우팅(Routing)과 교착상태(Deadlock) 2.6 돌명판(Tablets of Stone) - 네트워크 통신 프로토콜", " Chapter 2 제 2 부 컴퓨터를 동작시키기 — 알고리즘 전함 (battleship)—검색 알고리즘 가장 가벼운 것과 가장 무것운 것—정렬 알고리즘 시간내 일을 마치기—정렬 네트워크(Sorting Network) 진흙도시 프로젝트—최소생성나무(Minimal Spanning Trees) 오렌지 게임—네트워크 라우팅(Routing)과 교착상태(Deadlock) 돌명판(Tablets of Stone) — 네트워크 통신 프로토콜 컴퓨터를 동작시키기 컴퓨터는 미리 준비된 명령어 목록에 따라 동작합니다. 명령어는 컴퓨터로 하여금 정보를 정렬하고, 찾고, 전송할 수 있게 합니다. 이러한 작업들을 가능하면 빨리 수행할 수 있도록, 대용량 데이터 속에서 원하는 정보를 찾고, 네트워크를 통해서 정보를 송신하기 위해서 좋은 방법이 필요합니다. 알고리즘(algorithm)은 작업을 수행하기 위한 명령어 집합입니다. 알고리즘 아이디어는 컴퓨터 과학의 핵심입니다. 알고리즘은 컴퓨터로 하여금 어떻게 문제를 해결해야 하는지 지정합니다. 어떤 알고리즘은 다른 알고리즘보다 빠릅니다. 새로이 발견된 많은 알고리즘은 이전에 상대적으로 너무 오랜 시간 걸려 실행불가능하다고 생각되었던 문제를 풀 수 있도록 합니다. 예를 들어, 원주율(pi)의 백만 자리를 찾는다거나 월드와이드웹(World-Wide Web)에 여러분의 이름이 포함된 모든 페이지를 찾는다거나, 컨테이너에 짐을 넣는 가장 좋은 방법을 찾는다거나, 100자리 소수를 찾는다던가 하는 것입니다. 알고리즘(algorithm) 어원은 Mohammed ibn Musa Al-Khowarizmi 이름에서 나왔는데, Khowarizm 출신 모세의 아들 모하메드(Mohammed)는 기원후 800년경 바그다드의 지혜의 집(House of Wisdom)으로 알려진 학교에서 일하게 되었다. 모하메드의 저작은 아랍의 힌두예술에 전해졌고, 유럽으로 전파되었다. 1120년 라틴어로 변역되었고, 첫 단어가 “Dixit Algorismi”이다. 2.1 전함 - 검색 알고리즘 2.1 개요 컴퓨터로 대량의 데이터에서 정보를 찾아야 하는 작업이 많은데, 이런 작업을 수행하기 위해서 빠르고, 효율적인 방법이 필요합니다. 이번 활동에서는 선형 검색(linear &gt; searching), 이진 검색(binary searching), 해싱(hashing)이라는 3 종류의 다른 검색 기술을 학습합니다. 2.1 교과학습 연계 수학 : 숫자 레벨 3이상. 숫자 탐구: 이상, 이하, 같다. 기하 레벨 3 이상. 모양과 공간 탐색: 좌표 2.1 기술 논리적 추론 (Logical reasoning) 2.1 나이 9세 이상 2.1 학습 교재 아이들 각자가 필요한 것 전함 게임 사본 1번 게임: 1A, 1B 2번 게임: 2A, 2B 3번 게임: 3A, 3B 예비 게임으로 1A’, 1B’, 2A’, 2B’, 3A’, 3B’ 시트가 몇 장 더 필요할 수 있다. 2.1.1 언플러그드 활동 동영상 EBS 링크 동영상 (검색) EBS 링크 동영상 (순위) 2.1.2 전함 (Battleships) 2.1.2.1 들어가는 활동 아이는 전함 게임을 통해 컴퓨터가 어떻게 탐색을 수행하는지 체험할 수 있습니다. 게임 속에서 배를 어떻게 구해야 할까를 생각하게 합시다. 대략 15명 정도 어린이를 교실 앞에 줄을 세웁니다. 각 아이에게 무작위로 두 자리 숫자가 적힌 카드를 갖게 합니다. (카드 값은 00에서 99까지 난수입니다.) 교실의 &gt; 나머지 아이들이 숫자를 볼 수 없도록 잘 숨깁니다. 줄을 서지 않은 다른 아이에게 4~5개 사탕이 담긴 상자를 나눠줍니다. 이 아이의 임무는 주어진 숫자를 찾는 것입니다. 카드의 숫자를 보기 위해서 사탕을 “줄” 수도 &gt; 있습니다. 모든 사탕을 사용하기 전에 정답을 찾는다면, 나머지 사탕을 가집니다. 여러 차례 반복합니다. 이제 다시 카드를 섞어 다시 나누어줍니다. 이번에는 아이들이 오름차순으로 정렬하게 합니다. 검색과정을 반복하여 숫자를 찾아냅니다. 만약 숫자카드가 정렬되어 있다면, 중간 아이의 카드를 펴봄으로써 단 하나의 사탕으로 절반의 아이를 후보에서 제외할 수 있습니다. 이 과정을 반복함으로써, 단지 사탕 &gt; 3개로 정답을 찾을 수 있습니다. 분명히 이 방법은 효율적입니다. 2.1.2.2 활동 아이는 전함게임을 통해 컴퓨터가 어떻게 탐색을 하는지 간접적으로 느낄 수 있습니다. 아이들은 게임을 진행하면서, 전함을 찾아내기 위해 사용하는 전략들에 관해서 &gt; 사고하게 됩니다. 2.1.3 전함 — 선형 검색 게임 2.1.3.1 아이에게 다음 명령을 전달하세요. 2인 1조로 짝을 만드세요. 1명은 1A 시트(sheet)를 다른 한 명은 1B시트를 가지세요. 자신의 시트를 짝꿍에게 절대 보여주지 마세요. 모두 게임 시트 맨윗줄 전함 하나에 동그라미를 치세요. 짝꿍에게 그 번호를 알려주세요. 이제 교대로, 짝꿍의 전함이 어디에 있는지 맞춰보세요. (여러분이 배의 이름(영문 문자)을 말하고, 짝꿍이 그 이름의 전함 번호를 답합니다.) 짝꿍의 배를 맞출 때까지 얼마나 많이 대포를 쏘았나요? 대포 발사 횟수가 점수이고, 당연히 적은 횟수가 승리합니다. (시트 1A과 1B외에 더 게임을 하고 싶은 어린이와, 잘못해서 우연히 상대방의 시트를 본 아이를 위해서 시트 1A’과 1B’가 준비되어 있습니다. 추후 게임을 더 진행하도록 &gt; 시트 2A’, 2B’, 3A’, 3B’ 예비시트도 준비되어 있습니다.) 2.1.3.1 후속 토론 게임 점수가 몇 점인가요? 가능한 최소점수와 최대점수는 얼마가 될까요? (아이들이 같은 전함을 두 번 쏘지 않았다면, 최소 1과 최대 26입니다. 모든 위치를 하나씩, 하나씩, 검색하기 때문에 이 &gt; 방법을 “선형 검색(linear search)”이라고 부릅니다. 2.1.4 전함 — 이진 검색 게임 2.1.4.1 지시 사항 이번 게임의 방식은 이전 게임과 동일하지만, 전함의 숫자가 오름차순으로 정렬되어 있습니다. 게임을 시작하기 전에 아이들이게 설명해 주세요. 2인 1조로 짝을 만드세요. 1명은 2A 시트(sheet)를 다른 한 명은 2B시트를 가지세요. 자신의 시트를 짝꿍에게 보여주지 마세요. 모두 게임 시트 맨위줄 전함 한개에 동그라미를 치세요. 짝꿍에게 번호를 일러주세요. 이제 교대로, 짝꿍의 전함이 어디에 있는지 맞춰보세요. (여러분이 배의 이름(영문 문자)을 말하고, 짝꿍이 그 이름의 전함 번호를 답합니다.) 짝꿍의 배를 격침시킬 때까지 얼마나 많이 대포를 쏘았나요? 대포 발사 횟수가 점수이고, 당연히 적은 횟수가 승리합니다. 2.1.4.2 후속 토론 게임점수가 몇 점인가요? 점수 적은 사람은 무슨 전략을 사용했을까요? 여러분은 먼저 어느 전함을 선택했나요? (중간 전함은 선택된 전함이 왼쪽이나 오른쪽 절반에 있다고 말해줍니다.) 여러분은 다음으로 어느 전함을 선택했나요? (다시, &gt; 선택한 절반에서 한가운데 전함을 선택하는 것이 가장 좋은 최선의 전략입니다.) 만약 상기 전략을 사용한다면, 목표로하는 전함을 찾기 위해 얼마나 많은 공격이 필요할까요? (최대 5회). 문제를 두 부분으로 나누어서 찾아가기에 이 압업을 “이진 검색(&gt; binary search)”이라고 합니다. 2.1.5 전함 — 해싱 검색 게임 2.1.5.1 지시 사항 앞의 게임과 마찬가지로 각자 시트를 가지고, 짝꿍에게 선택한 전함의 숫자를 말하세요. 이 게임에서는 전함이 어느 열(0~ 9)에 있는지 찾습니다. 전함 번호의 각 자리 숫자를 단순히 더합니다. 합계의 마지막 숫자가 배가 있는 열의 번호입니다. 예를 들어, &gt; 2345 전함은 2 + 3 + 4 + 5 를 계산하여 14입니다. 합계의 마지막 숫자가 4이므로, 그 전함 4 열에 있는 것입니다. 열을 알면 해당 열중에서 목표 전함이 어느 전함인지를 &gt; 찾아내면 됩니다. 모든 숫자를 밀어 넣고 쥐어짰기 때문에 이 방법을 해싱(hashing)이라고 합니다. 이 새로운 검색 전략을 사용해서 게임을 시작합시다. 다른 열을 선택하여 동일한 시트로 여러 번 게임을 진행할 수 있습니다. (다른 게임과 달리 예비 3A와 3B 시트를 반드시 짝으로 사용합니다. 왜냐하면, 열에 들어있는 전함 패턴이 상응해야 되기 때문입니다.) 2.1.5.2 후속 토론 앞에서 진행했던 것과 동일하게 점수를 모아 토론하세요. 어떤 전함을 빠르게 찾을 수 있나요? (열에 혼자만 있는 전함) 어느 전함은 찾기가 더 어려웠나요? (많은 다른 많은 전함이 있는 열에 있는 전함) 세가지 검색 방법 중 가장 빠른 것은 무엇인가요? 이유는 무엇일까요? 각 3 종류의 검색 방법의 장점은 무엇인가요? 두번째 검색 전략(이진 검색)은 첫번째 검색 전략(순차 검색) 보다 빠르지만, 첫번째 검색 전략은 전함을 정렬할 필요는 &gt; 없습니다. 세번째 검색전략(해싱 검색)은 다른 둘 보다 빠르지만, 때때로 매우 느릴 수 있습니다. 최악의 경우, 모든 배가 같은 열에 위치한다면, 첫 번째 전략과 마찬가지 &gt; 속도로 매우 늦어버립니다. 2.1.6 확장 활동 어린이에게 자신만의 3 종류의 게임을 만들게 합시다. 두번째 게임은 숫자를 오름차순으로 정렬해야 합니다. 어떻게 하면 해싱 검색 게임을 어렵게 만들 수 있는지 &gt; 생각하게 합시다. (모든 전함이 1 개의 열에 위치하는 것이 가장 어렵습니다). 가장 쉽게 되는 방법도 생각하게 합시다. (각각의 열에 동일한 숫자만큼 전함을 배치합니다.) 만약 찾는 전함이 없는 경우는 어떻게 됩니까? (선형 검색방법은 없다는 것을 파악할 때까지 26 회 공격을 합니다. 이진 검색방법은 5 회 필요합니다. 해싱 검색방법은 &gt; 해당 열에 얼마나 많은 전함이 배치되어 있는지에 따라 결과가 달라집니다.) 이진 검색방법을 사용하여 100대 전함이 있는 경우 얼마나 많은 공격을 해야 전함을 찾을 수 있을까요? (약 6 회), 1,000대의 전함은 어떨까요? (약 9 회) 100만대라면 (&gt; 약 19 회)? (전함 수가 증가하는 속도에 비해서, 필요한 공격의 횟수는 매우 느리게 증가하는 것에 주목하십시요. 매번 전함의 수가 두 배가 될 때마다, 1회 추가 공격이 &gt; 필요하니, 전함 숫자의 대수(logarithm)에 비례합니다.) 2.1.7 컴퓨터 과학 핵심 개념 컴퓨터는 많은 정보를 저장하고 빠르게 검색해서 찾아낼 수 있어야 합니다. 가장 어려운 검색 과제 중 하나는 인터넷 검색 엔진이 1초도 되지 않는 시간 안에 수십억 웹페이지를 검색하는 것입니다. 단어, 바코드(bar code)번호, 저자 이름 같은 컴퓨터가 검색에 사용하는 데이터를 “검색키”(search key)라고 합니다. 컴퓨터는 정보를 매우 빨리 처리할 수 있어서, 정보를 찾기 위해 저장소 처음부터 원하는 정보가 찾아질 때까지 순차적으로 찾는 방법을 생각할 수 있습니다. 이 방법이 순차검색게임에서 수행했던 방법입니다. 하지만 이 방법은 매우 느리고, 컴퓨터에게 조차도 부담이 됩니다. 예를 들어, 슈퍼마켓 선반에 10,000 종의 제품이 진열되어 있다고 가정합시다. 계산대에서 바코드를 스캔한다면, 제품명과 가격을 확인하기 위해 10,000 번 컴퓨터가 작업을 수행해야 합니다. 각 제품을 스캔해서 확인하는데 천분의 1초 걸린다고 하더라도, 전체 제품을 스캔하는데 10초가 소요됩니다. 가족이 먹을 식료품 값을 지불할 경우 시간이 얼마나 소요될지 상상해 보세요. 좀더 좋은 방법은 이진 검색(binary search) 방법입니다. 이 방법을 사용하려면, 숫자가 정렬되어 있어야 합니다. 숫자 리스트의 중간 항목을 확인하고, 검색키가 양쪽 중 한쪽 절반에 있는지 확인합니다. 원하는 항목을 찾을 때까지 이 과정을 계속 반복합니다. 슈퍼마켓 사례로 돌아가서, 1 만개의 제품에 대해서 원하는 품목을 14 회 만에 찾을 수 있고, 0.02 초로 시간이 걸리는지 알아채기 쉽지 않습니다. 데이터를 찾는 세 번째 전략은 ’해싱’검색 방법입니다. 정확한 정보의 위치를 표시하기 위해 검색키(search key)를 조작합니다. 예를 들어, 검색키가 전화번호라면, 전화번호의 모든 자리수 숫자를 더한 후에 11로 나눈 나머지 값을 취합니다. 데이터의 일부분이 처리되는 다른 데이터와 관련이 있다는 점에서, 해쉬키는 네번째 활동에서 다룬 자릿수 검증(check digits)과 유사합니다. 대체로 이 방법을 사용하여 컴퓨터는 바로 정보를 찾아낼 수 있습니다. 드물기는 하지만, 복수키가 동일하게 위치한 경우, 지시한 정보를 찾을 때까지 컴퓨터가 다시 검색을 해야하므로 시간이 좀더 걸립니다. 데이터를 순서대로 정렬할 필요가 없거나, 심야시간의 경우처럼 늦은 속도가 문제가 되지 않다면, 컴퓨터 프로그래머는 검색기법으로 해싱 전략을 기본으로 사용합니다. 2.2 가장 가벼운 것과 가장 무거운 것 - 정렬 알고리즘 2.2 개요 컴퓨터를 이용하여 이름을 가나다 순으로, 약속이나 전자우편을 날짜 순으로, 상품을 가격 순으로 정렬할 수 있습니다. 정렬로 물건을 빠르게 찾을 수 있고, 끝 쪽에 위치한 &gt; 극단값을 보기도 쉽습니다. 학교 시험 성적을 정렬한다면, 최고점과 최저점은 명확해 집니다. 빠른 컴퓨터에서도 잘못된 정렬 알고리즘을 사용하게 된다면 매우 큰 목록을 정렬하는데 시간이 오래 걸립니다. 다행히도 정렬을 빠르게 하는 몇가지 방법이 알려져 있습니다.&gt; 이번 활동에서 정렬을 위한 다양한 방법을 익히게 됩니다. 간단한 알고리즘에 비해서 좀더 똑똑한 알고리즘이 작업을 빨리 수행하는 것도 보게 됩니다. 2.2 교과학습 연계 수학 : 숫자 레벨 2 이상. 실제 계량 작업을 수행. 2.2 기술 평형 저울 사용하기 순서대로 정렬하기 비교하기 2.2 나이 8세 이상 2.2 학습 교재 활동에 참가하는 아이들은 다음을 준비하세요. 다른 무게를 가지는 동일한 크기의 용기 8 개 한 세트(예. 모래 혹은 물로 채워진 우유통, 필름통) 평형 저울 워크시트 활동 : 무게 정렬 (70 페이지) 워크시트 활동 : 나누어서 해결하기 (71페이지) 2.2.1 언플러그드 활동 동영상 EBS 링크 동영상 언플러드그 동영상 2.2.2 가장 가벼운 것과 가장 무거운 것 2.2.2.1 토론 컴퓨터를 이용하여 종종 물건을 정렬하는데 사용합니다. 정렬이 중요한 장소나 사례에 대해서 자유로이 생각을 말씀해보세요. 만약 물건이 정렬되지 않는다면 무슨 일이 &gt; 생길까요? 컴퓨터는 통상 한번에 두개 값을 비교합니다. 아이들은 이러한 제약사항을 이용하여 컴퓨터가 어떻게 동작하는지 아이디어를 얻게 됩니다. 2.2.2.2 활동 아이들을 그룹으로 나눕니다. 각 그룹은 66 페이지의 활동 워크시트와 평형 저울과 추가 필요합니다. 아이들이 활동을 수행한 후에 결과를 토론합니다. 2.2.2.3 워크시트 활동 — 무게 정렬하기 목적: 알 수 없는 무게를 가진 대상을 순서대로 정렬하는 가장 좋은 방법 찾기 필요한 준비물: 물 혹은 모래, 서로 구별할 수 없는 용기 8개, 평형 저울 한 세트 따라 하기: 각 용기를 다른 양의 모래 혹은 물로 채우고 밀봉하세요. 각 용기를 뒤죽박죽 섞어서, 더 이상 각 용기의 무게를 짐작할 수 없게 합니다. 가장 가벼운 것을 찾으세요. 가장 가벼운 것을 찾는 손쉬운 방법은 무엇일까요? 주의: 각 용기의 무게가 얼마인지 측정하기 위해서만 평형저울을 사용합니다. 단, 한번에 용기 두개 무게만 비교할 수 있습니다. 무작위로 용기 3개를 골라서 평형저울만 사용해서 가장 가벼운 것부터 가장 무거운 것까지 순서대로 정렬하세요. 어떻게 수행했는지 자세하게 작성하고 말해보세요. &gt; 비교횟수를 적게 했던 것은 어떤 방식이었나요? 왜 그런지 이유를 설명해 보세요. 모든 용기를 가장 가벼운 것부터 가장 무거운 것까지 정렬해 보세요. 정렬 작업을 마쳤다고 생각한다면, 용기를 둘씩 짝지어 무게를 재서 용기가 순서대로 정렬되었는지를 확인해보세요. 2.2.2.4 선택 정렬 (Selection Sort) 선택 정렬(selection sort)은 컴퓨터가 사용하는 정렬 방법 중의 하나입니다. 어떻게 작동하는지 살펴봅시다. 정렬대상이 위치한 곳과 정렬결과를 놓을 곳으로 나누고, &gt; 가장 가벼운 것을 골라 정렬결과 장소를 옮겨놓습니다. 그 다음으로 가벼운 것을 골라 옮겨 놓는 것을 반복하여 더 이상 정렬대상에 아무것도 없을 때까지 반복합니다. 얼마나 많은 비교를 수행했는지 횟수를 세어보세요. 심화문제: 8개 물체를 정렬하기 위해서 얼마나 많은 비교를 수행했는지 수학적으로 보이세요. 9개의 물체 정렬은? 20개의 물체 정렬은? 2.2.3 워크시트 활동 — 나누어서 해결하기 2.2.3.1 퀵정렬(Quicksort) 퀵정렬은 특히 정렬 목록이 많을 때, 선택 정렬보다 훨씬 빠르다. 사실 지금까지 알려진 가장 좋은 정렬방법 중의 하나다. 다음은 어떻게 퀵정렬이 작동하는지 보여준다. 무작위로 정렬 대상 중에서 하나를 골라 평형저울 한쪽에 놓습니다. 남아있는 정렬대상을 앞에서 선택한 물체와 비교를 합니다. 가벼운 것은 왼쪽에, 무작위로 고른 정렬기준은 가운데, 무거운 것은 오른쪽에 위치하게 됩니다. (우연히, 한쪽에 &gt; 더 많은 물체가 몰려있을 수도 있습니다.) 왼쪽편과 오른편 그룹에서도 상기와 동일한 과정을 반복합니다. 무작위로 선택한 1 개 물체를 반드시 중간에 두는 것을 잊지 마십시오. 1개 이상의 물체를 가진 그룹이 없을 때까지 이 절차를 반복하여 1개 이상의 물체를 담고 있는 그룹은 하나도 남지 않게 됩니다. 모든 그룹에 1개 물체가 있을 때, 모든 &gt; 물체는 가벼운 것부터 가장 무거운 것 순으로 정렬이 완료됩니다. 이 과정에서 얼마나 많은 비교를 했습니까? 우연히 가장 가벼운 것, 혹은 가장 무거운 것을 선택하지 않는다면, 퀵정렬이 선택정렬보다 더 효과적이라는 것을 알게 됩니다. 운이 좋아서 중간을 고른다면, 선택정렬 28회 &gt; 비교 횟수와 비교하여 단지 14 회 비교횟수만 필요합니다. 퀵정렬은 운이 나빠도 선택정렬만큼, 대부분의 경우 선택 정렬보다 훨씬 빠르다! 심화문제: 우연히 퀵정렬이 가장 가벼운 물체를 선택했다면, 얼마나 많은 비교 작업을 수행해야 할까요? 2.2.3.2 변형과 확장 다양하게 많은 정렬 방법들이 개발되었습니다. 다음 방법들을 적용하여 무게를 정렬해봅시다. 삽입정렬(Insertion sort) 아래의 그림처럼, 정렬되지 않은 그룹에서 객체를 하나씩 빼서 정렬된 그룹에 올바른 위치에 삽입합니다. 매번 삽입할 때마다 정렬되지 않은 &gt; 그룹의 객체는 줄어들게 되고, 정렬된 객체 목록는 늘어나게 되고, 궁극적으로 전체 리스트 객체가 정렬됩니다. 트럼프 카드 게임을 하는 카드 플레이어가 카드를 정렬하는데 &gt; 동일한 방법을 사용하는데, 정렬할 카드를 이미 정렬된 카드를 가진 손으로 한 장씩 뽑아서 옮깁니다. 버블정렬(Bubble sort)은 순서가 뒤바뀐 객체 위치를 바꾸는 과정을 반복적으로 수행합니다. 순서를 바꾸는 작업을 반복적으로 수행해서 더 이상 바꿀 객체가 없을 때 &gt; 멈추게 되고, 모든 객체는 정렬이 됩니다. 이 방법이 그다지 효율적이지 않지만, 다른 방법보다 이해하기 쉽다고 생각하는 사람도 많습니다. 병합정렬(Mergesort)은 ‘나누어 해결하기(divide and conquer)’ 전략에 기초한 정렬방법입니다. 첫번째로, 정렬대상이 짝수라면 동일 크기를 가지는 그룹 두개로, &gt; 홀수라면 거의 동일한 크기의 그룹 두개로 나눕니다. 각각 두 그룹을 정렬하고, 정렬된 두 그룹을 병합합니다. 정렬된 두개 그룹을 병합하는 것은 쉽습니다. 정렬된 두 &gt; 그룹에서 가장 작은 것을 뽑아 비교하여 병합하는 과정을 반복합니다. 아래 그림에서 40그램과 60그램이 각 그룹에서 가장 작은 것이고, 이를 비교하여 40g이 더 작기 때문에 &gt; 추가됩니다. 이제 더 작게 되었는데 어떻게 정렬할까요? 간단합니다. 다시 병합정렬을 이용합니다. 이를 반복하면 결국 모든 정렬 대상은 각 그룹별로 1개만 남게 되고 &gt; 병합정렬을 이용한 모든 정렬은 끝나게 됩니다. 2.2.4 컴퓨터 과학 핵심 개념 정보가 순서로 나열되어 있으면 훨씬 찾기가 쉬워집니다. 전화번호부, 사전, 책 색인은 모두 가나다 순서로 되어 있지만, 만약 정렬이 되어 있지 않은 상황을 생각한다면, &gt; 우리는 매우 불편한 생활을 살게 될 것입니다. 지출경비 같은 숫자 목록이 잘 정렬되어 있다면, 가장 큰 숫자가 목록 상단에 위치하기 때문에 쉽게 찾을 수 있을 것입니다. &gt; 중복된 것은 함께 있기 때문에 찾기 쉬울 것입니다. 컴퓨터는 무언가를 정렬하는데 시간이 많이 소요되기 때문에 컴퓨터 과학자들은 빠르고 효율적인 정렬방법을 찾으려고 했습니다. 삽입정렬, 선택정렬, 버블정렬 같은 느린 정렬방법은 특별한 상호아에 유용할 수도 있지만, 퀵정렬 같은 빠른 정렬방법을 자주 사용합니다. 퀵정렬은 재귀(recursion)라는 개념을 사용합니다. 재귀방법은 정렬 대상 목록을 작은 그룹으로 나누고 각 그룹에 동일한 방법을 반복해서 수행하는 것입니다. 이 특별한 접근법을 ‘나누어 해결하기(divide and conquer)’라고 합니다. 정렬 작업을 수행하기 위해서, 목록을 나누어 해결할 수 있을 만큼 적당히 작게 만드는 과정을 반복합니다. 퀵정렬은 각 그룹 객체가 1개만 남을 때까지 목록을 분할합니다. 한 품목을 정렬하는 것은 어느 방법을 사용해도 차이가 없습니다! 퀵정렬은 복잡할 수 있지만, 다른 방법보다 실무에서 훨씬 빠른 정렬방법입니다. 2.2.5 해답과 힌트 가장 가벼운 것을 찾는 최선의 방법은 지금까지 나온 가장 가벼운 것을 높고 각 객체를 차례차례 살펴보는 것이다. 즉, 두 객체를 비교하여 더 가벼운 것을 보관한다. &gt; 이것을 다시 다른 것과 비교하여 더 가벼운 것을 보관한다. 모든 객체에 대해서 이 방법을 반복한다. 평행저울에 무게를 달아 비교하자. 세번 비교를 통해서 가능한데, 만약 아이들이 추이관계(transitive relation)를 이해한다면 때때로 두 번으로도 충분하다. (만약 A가 &gt; B보다 가볍고, B가 C보다 가볍다면, A는 C보다 가볍다.) 심화문제 선택정렬에서 비교횟수를 쉽게 계산하는 방법을 소개합니다. 객체 2개 중에서 작은 것을 찾는 것은 1회, 객체 3개는 2회, 객체 4개는 3회… 객체 8개를 정렬하기 위해서 가장 가벼운 것을 찾기 위해서 7번 비교를 하고, 두 번째 작은 것을 찾기 위해서는 6번, 그 다음 작은 것은 5회, … 그래서, 7 + 6 + 5 + 4 + 3 + 2 + 1 = 28 비교횟수 n 개 개체는 1 + 2 + 3 + 4 +… + n – 1 번의 정렬횟수가 필요합니다. 정렬횟수 총합을 구하기 위해서 그룹을 지으면 쉽습니다. 예를 들어, 1 + 2 + 3 + … + 20 합계를 구하기 위해, 아래와 같이 그룹으로 묶게 되면, (1 + 20) + (2 + 19) + (3 + 18) + (4 + 17) + (5 + 16) + (6 + 15) + (7 + 14) + (8 + 13) + (9 + 12) + (10 + 11) = 21 × 10 = 210 따라서, 선택정렬의 비교횟수 총합: 1 + 2 + 3 + 4 … + n–1 = n(n–1)/2. 2.3 시간 내 일을 마치기 - 정렬 네트워크 2.3 개요 컴퓨터가 빠르기는 하지만, 컴퓨터가 문제를 해결하는데 분명히 한계가 있다. 컴퓨터의 속도를 높이는 방법 중의 하나는 여러 대의 컴퓨터로 문제를 나누어서 해결하는 것이다&gt; . 이번 활동에서, 동시에 여러 개를 비교해서 정렬할 수 있는 정렬망(sorting networks)에 대해 알아봅니다. 2.3 교과학습 연계 수학 : 숫자 레벨 2 이상. 숫자 탐색: 이상, 이하. 2.3 기술 비교하기 정리하기 알고리즘 개발하기 협업으로 문제 해결하기 2.3 나이 7세 이상 2.3 학습 교재 야외 활동에 필요한 것들. 분필이나 그릴 것 6장 카드로 구성된 복사본 두벌: 복사 마스터 정렬네트워크 카드 (77 페이지)를 오려 붙이세요. 초시계(stopwatch) 2.3.1 언플러그드 활동 동영상 한글 동영상 영어 동영상 2.3.2 정렬 네트워크 (Sorting Network) 먼저 활동을 시작하기 전에, 지면에 아이가 걸을 정도 크기로 네트워크 다이어그램을 그립니다. 교실에서는 큰 종이나 시트를 사용하면 좋습니다. 2.3.2.1 지시사항 이번 활동에서는 정렬 네트워크를 사용해서 컴퓨터가 어떻게 난수를 정렬하는지 학습할 것입니다. 아이들을 6 명이 1 조가 되도록 구성합니다. 한번에 한팀(6명 1조)만 정렬 네트워크게임을 할 수 있습니다. 각 조원은 숫자가 적힌 카드를 받습니다. 각 조원은 무작위로 섞여 왼편(들어가기) 사각형 위에 섭니다. 뒤죽박죽으로 번호 순서가 섞여야 합니다. 각 조원은 화살표 선을 따라 움직이고, 원(‘○’)에 도착하면 다른 조원이 도착할 때까지 기다립니다. 친구 조원이 ‘○’’ 곳까지 왔다면 당신의 카드와 친구의 카드를 비교해 봅시다. 작은 숫자 카드를 가지고 있는 사람은 왼쪽 줄을 따라 이동합니다. 더 큰 숫자 카드를 &gt; 가진 사람은 오른쪽 줄을 따라 이동합니다. 반대쪽 끝에 모두 도착했을 때, 정렬이 제대로 되었는지 확인합니다. 잘못되면 다시 처음부터 다시 시작합니다. 예를 들면, 네트워크 접점(‘○’)에서 작은 숫자는 왼쪽으로, 그렇지 않으면 오른쪽으로 진행한다는 것을 제대로 이해할 수 있는지 &gt; 확인합시다. 2.3.2.2 복사 마스터: 정렬 네트워크 2.3.2.3 변형 아이들이 활동에 익숙해지면, 초시계를 사용하여 한 조가 네트워크를 통과하는데 얼마나 걸리는지 시간을 측정합니다. 좀더 큰 수를 카드로 사용합니다. (예, 복사 마스터 세자리 숫자를 복사해서 사용하세요.) 비교하기 힘든 큰 숫자 카드를 만들어 봅시다. 또는 단어 카드를 사용하여 가나다 순서나 영어 알파벳 순서로 정렬해 봅시다. 2.3.3 확장 활동 '1. 작은 숫자를 가진 사람이 왼쪽 대신에 오른쪽으로 가면, 혹은 역으로 하면 무슨 일이 생길까요? (숫자는 반대로 정렬될 것입니다.) 네트워크 역방향으로 진행하면 어떻게 될까요? (반드시 동작하지는 않습니다. 아이들은 제대로 정렬되지 않고 나오는 경우를 발견할 수 있어야 합니다.) '2. 좀더 크거나 작은 네트워크를 설계해 보세요. 예를 들어 숫자 세개를 정렬하는 네트워크가 있습니다. 아이들 각자 자신만의 네트워크를 그려보세요. '3. 다음은 입력 숫자 4개를 정렬하는 서로 다른 두 개의 네트워크입니다. 어느 쪽이 더 빠를까요? (두 번째가 더 빠릅니다. 첫 번째 네트워크는 순차적으로 모든 비교를 &gt; 수행하는 반면에 두 번째 네트워크는 동시 비교를 수행합니다. 첫번째 네트워크는 순차처리 예가 되고, 반면에 두번째 네트워크는 더 빠른 병렬처리를 사용합니다.) '4. 좀더 커다란 정렬 네트워크를 만들어 보세요. '5. 입력 데이터 중에서 최소 혹은 최대값을 찾아내기 위해서도 네트워크를 활용합니다. 예를 들어, 여기 최소 출력값을 얻기 위한 입력 숫자 8개를 가진 네트워크가 &gt; 있습니다. (다른 값들은 네트워크에서 사라집니다.) '6. 일상생활에서 병렬처리하면 빠르게 할 수 있는 일이 어떤게 있을까요? 병렬적으로 처리해도 별로 효과가 없는 일은 무엇일까요? 예를 들어, 요리를 할 때 조리기구를 하나만 사용한다면 무척이나 느릴 것입니다. 왜냐하면 조리기구를 순차적으로 요리를 한다면, 요리 하나가 끝날 때까지 기다려야 하기 때문에 시간이 오래 걸릴 것입니다. 더 많은 사람을 고용해서 빨리 끝날 수 있는 일과 그렇지 못한 일은 무엇이 있을까요? 2.3.4 컴퓨터 과학 핵심 개념 오늘날 컴퓨터를 점점 더 많이 사용함에 따라 더 빠르게 컴퓨터가 정보를 처리해주기를 원합니다. 컴퓨터 속도를 높이는 방법은 동일한 작업을 수행함에 있어 더 적은 연산절차(활동 6과 7에서 학습)를 가진 프로그램을 작성하는 것입니다. 문제를 더 빠르게 해결하는 다른 방법은 동시에 같은 작업을 나누어서 다수 컴퓨터로 작업을 수행하는 것입니다. 예를 들어, 숫자 6개 정렬 네트워크에서, 6개 숫자를 &gt; 정렬하기 위해서 12번의 비교가 필요하지만, 동시에 최대 3회 비교를 한번에 수행했다. 이것이 의미하는 것은 정렬에 걸리는 시간이 5회 비교작업 시간과 동일하다는 것이다. &gt; 이 병렬 네트워크는 목록을 순차적으로 비교하여 처리하는 것보다 두배 이상 빨리 정렬할 수 있다. 모든 작업이 병렬처리를 통해서 빨라질 수 있는 것은 아닙니다. 한 사람이 10 미터 도랑을 판다고 상상해 봅시다. 만약 10 사람이 1 미터씩 도랑을 판다면, 10 미터 파는 &gt; 작업은 훨씬 빠르게 끝납니다. 하지만 동일한 전략이 10미터 깊이 땅굴을 팔 때는 사용될 수 없습니다. 첫 1 미터 작업이 끝날 때까지 다음 1미터 작업을 할 수 없기 &gt; 때문입니다. 컴퓨터 과학자들은 컴퓨터를 병렬로 작동함으로써 빠르게 문제를 해결하는 방법을 찾으려고 적극적으로 노력하고 있습니다. 2.4 진흙도시 프로젝트 - 최소생성나무(Minimal Spanning Trees) 2.4 개요 우리 사회는 전화, 에너지 공급, 컴퓨터, 도로 등 다양한 네트워크로 연결되어 있습니다. 각각의 네트워크에는 도로, 케이블, 혹은 무선 네트워크를 어떻게 배치하는지에 &gt; 대한 설계 결정이 녹여져 있습니다. 효율적으로 네트워크에서 객체를 연결하는 방법을 파악할 필요가 있습니다. 2.4 교과학습 연계 수학 : 기하 레벨 2/3 이상. 모양과 공간 탐색: 지도에서 최단 거리 찾기 2.4 기술 문제 해결하기 2.4 나이 9세 이상 2.4 학습 교재 아이들이 필요한 것 워크시트 활동: 진흙도시 문제 (page 83) 판지를 작은 사각형으로 자른 것 (대략 아이당 40개) 2.4.1 언플러그드 활동 동영상 EBS 링크 동영상 언플러드그 동영상 찾고 있음 2.4.2 진흙 도시 2.4.2.1 들어가며 이번 활동을 통해서 현실 세계 문제에서 어떻게 최적의 해결책을 찾는데 컴퓨터를 이용하는지 보여줍니다. 예를 들어, 모든 가정에 전기를 공급하는 전선과 도시 가스를 &gt; 공급하는 가스관을 어떻게 연결하는지가 좋은 사례입니다. ‘진흙도시’(Muddy City) 문제를 설명하는 78 페이지 워크시트를 사용하세요. 2.4.2.2 후속 토론 아이들이 발견한 해결책을 공유하세요. 아이들은 무슨 전략을 사용했나요? 최적 해결책을 찾는 좋은 방법중의 하나는 빈 지도에서 시작해서, 빈 지도에서 점차적으로 도로 포장을 늘려가면서 모든 집들이 연결되게 하는 것입니다. 도로 포장은 최단 &gt; 거리에서 길어지는 순서대로 진행하지만, 이미 연결된 집은 추가로 연결을 하지 않습니다. 만약 동일 길이 포장도로가 추가되어 순서를 바꾼다면 다른 해결책을 찾은 것입니다&gt; . 두 가지 가능한 해결책을 다음에 있습니다. 다른 전략은 모든 도로가 포장된 상태에서 시작해서, 필요하지 않은 도로포장를 제거하는 것입니다. 하지만, 더 많은 노력이 듭니다. 현실세계에서 네트워크는 어디에 사용되고 있을까요? 컴퓨터 과학자는 이런 네트워크 표현을 “그래프(graph)”라고 합니다. 실제 네트워크를 그래프로 표현하여 마을과 마을을 연결하는 도로 설계 또는 지역과 지역을 연결하는 &gt; 항공로 설계와 같은 문제를 풀어 최상의 네트워크를 설계하는데 활용합니다. 두 점을 연결하는 최단 거리를 찾는 방법, 모든 점을 연결하는 가장 짧은 경로를 찾는 방법처럼 그래프를 적용한 많은 다양한 알고리즘이 있습니다. 2.4.3 워크시트 활동: 진흙 도시 문제 옛날에 전혀 도로가 없는 도시 하나가 있었습니다. 비가 온 뒤에 땅이 진흙탕이 되어 도시를 돌아다니는 것은 무척이나 어려웠습니다. 자동차는 진흙 웅덩이에 빠지고, &gt; 사람들 신발은 곧 더러워졌습니다. 진흙 도시 시장은 도로의 일부를 포장하기로 결정하였지만, 예산을 많이 사용하고 싶지는 않았습니다. 주민들이 수영장 건립을 원했기 &gt; 때문입니다. 그래서 시장은 다음의 두 가지 조건을 제시했습니다. 도로가 충분히 포장되어 누구나 자신의 집에서 다른 사람의 집으로 포장된 도로만을 이용하여 이동할 수 있어야 한다. 포장비용은 최대한 저렴하여야 한다. 다음에 마을 지도가 있습니다. 포장하기 위해서 돌을 사용하는데, 돌의 개수가 집과 집 사이를 포장하는데 드는 비용을 나타냅니다. 모든 집을 포장된 길로 연결하고 비용이 &gt; 최대한 저렴하게 경로를 구축해 보세요. (참고로, 다리는 포장에서 제외합니다.) 이 문제를 풀기 위해서 무슨 전략을 사용했나요? 2.4.4 변형과 확장 다음은 진흙 도시와 도로를 그래프로 표현한 사례입니다. 집은 원으로 표시하고, 진흙 도로는 선으로 표시하고, 도로 길이는 선 옆의 숫자로 표시합니다. 종종 컴퓨터 과학자와 수학자는 최적화 문제를 표현하기 위해 이런 종류의 그림을 사용하고, 그래프(graph)라고 합니다. 처음에는 혼동스러울 수 있습니다. 왜냐하면 &gt; 통계에서 사용하는 “그래프”는 숫자 데이터를 표현하기 위한 막대그래프 같은 차트를 의미하기 때문입니다. 하지만 컴퓨터 과학자가 사용하는 그래프는 이것과 연관되어 있지 &gt; 않습니다. 길이를 반듯이 도로 길이에 비례하여 작성할 필요는 없습니다. 자신만의 “진흙도시”와 같은 비포장 도로를 최소 비용으로 포장하는 문제를 만들어 봅시다. 지도를 그래프 형태로 보여주는 것도 좋습니다. 그리고 친구에게 그 문제를 풀게 &gt; 해 봅시다. 가장 좋은 해결책으로 얼마나 많은 도로가 포장되어거나 혹은 연결되어야 하는지 기술할 수 있는 규칙을 찾았습니까? 도시에 얼마나 많은 집이 있는지가 그 규칙과 관련이 있나요? 2.4.5 컴퓨터 과학 핵심 개념 여러분이 전기, 가스, 수도 등을 새로운 거주지에 공급하는 것을 설계한다고 가정해봅시다. 모든 집의 전선 혹은 파이프는 공공기업(한전, KT, 가스공사 등)에 연결되어야 &gt; 합니다. 각각의 집은 어떻게든 네트워크에 연결되어야 하지만 어떤 경로를 취할 것인가는 연결만 된다면 그다지 문제가 되지 않습니다. 네트워크 경로 길이가 최소가 되도록 설계하는 작업을 “최소생성나무”(minimal spanning tree)문제라고 합니다. “최소생성나무”는 가스나 전력 네트워크에만 유용한 것이 아닙니다. 컴퓨터 네트워크, 전화 네트워크, 송유관, 항공운항 경로 문제를 해결하는데 도움이 됩니다. 하지만, &gt; 여행의 최적 경로를 결정할 때는 비용이 얼마나 드는지, 여행이 얼마나 편안할지도 함께 고려해야 합니다. 단지 비용이 저렴하다는 이유로, 처음으로 여행가는 나라에 &gt; 비행기를 장시간 타면서 시간을 낭비하려는 사람은 많지 않을 것입니다. 비행경로나 화물 운송경로를 최소화하는데 사용되는 진흙도시 알고리즘은 여행경로와 같은 네트워크 &gt; 최적화하는 데에는 그다지 도움이 되지 않습니다. 최소생성나무 알고리즘은 그래프에 관한 다른 문제(예를 들어 “외판원 문제 [Travel Salesman Problem, TSP]”)를 해결할 때 단계중의 하나로서 유용합니다. 외판원 문제는 &gt; 네트워크의 모든 점을 방문하는 최소 경로를 찾는 것입니다. 최소생성나무 문제를 해결하는 효과적인 알고리즘과 방법이 있습니다. 최적의 해결책을 주는 간단한 방법은 아무 연결도 없는 상태에서 시작해서, 앞에서 연결되지 않은 &gt; 점들을 비용이나 크기가 커지는 순서대로 연결을 하는 것입니다. 1956년에 J.B. Kruskal이 발표하여 Kruskal 알고리즘이라고 합니다. “외판원 문제” 등, 그래프에 관한 많은 문제에 관해서는 지금도 컴퓨터 과학자가 가장 최선의 가능한 해결책을 찾아내는데 충분히 빠른 방법을 찾으려고 노력을 경주하고 &gt; 있습니다. 2.4.6 해답과 힌트 2.4.6.1 변형과 확장 도시에 집이 n개 있다면 얼마나 많은 도로 연결이 필요할까요? 최적의 해결책은 정확하게 n-1 개 연결을 갖는 것으로 밝혀졌다. n-1개 연결은 n 개 집을 연결하는데 충분하다. 왜냐하면, 연결을 하나 더 추가하는 것은 집 사이에 불필요한 대체가능한 연결을 하나 더 만들기 때문이다. 2.5 오렌지 게임 - 네트워크 라우팅(Routing)과 교착상태(Deadlock) 2.5 개요 자동차가 다니는 도로나 메시지가 지나가는 인터넷 같이 하나의 자원을 많은 사람이 공유하여 사용할 때, 교착상태(deadlock) 발생 가능성이 있다. 교착상태가 발생하는 것을 &gt; 피하는 방법은 협력하는 것이다. 2.5 교과학습 연계 수학 : 논리와 추론 개발하기 2.5 기술 협력하여 문제 해결하기 논리적 추론하기 2.5 나이 9세 이상 2.5 학습 교재 각 아이들에게 필요한 것 오렌지 두 개 혹은 테니스 공 부착이 가능한 이름표 또는 이름 스티커 2.5.1 언플러그드 활동 동영상 한글 동영상 영어 동영상 2.5.2 오렌지 게임 2.5.2.1 들어가며 이 게임은 협력하여 문제를 해결하는 게임이다. 참가자 전원이 자신의 이름이 이니셜로 새겨진 오렌지를 모두 갖는 것이 게임의 목표입니다. 5명 혹은 그 이상의 아이들이 한 그룹으로 원을 그려 앉습니다. 아이들 모두 자신의 이니셜을 이름표나 이름 스티커에 적습니다. 한 명을 제외한 모든 아이들은 오렌지 두 개에 자신의 이니셜을 붙입니다. 제외된 한 명은 하나만 &gt; 오렌지에 붙여 한 손에 들고 있고, 나머지 손은 빈손입니다. 원에 둘러 앉은 아이들에게 무작위로 오렌지를 나눠줍니다. 오렌지 하나만을 가진 한 명을 제외하고 모든 아이들은 오렌지 두개를 가집니다. (단, 어떤 아이도 자신의 &gt; 이니셜이 적힌 오렌지를 갖으면 안됩니다.) 자신의 이니셜을 가진 오렌지를 모든 아이들이 가질 때까지 아이들은 오렌지를 전달합니다. 이때 두 가지 규칙을 지켜야 합니다. 한번에 상대에게 전달할 수 있는 오렌지는 1 개뿐입니다. 바로 옆 사람의 손이 빈 경우에만 오렌지를 전달할 수 있습니다. (즉, 옆 사람에게 오렌지를 전달할 수 있는 아이는 한번에 1 명뿐입니다.) 만약 아이들이 욕심을 부려 자신의 이니셜이 적힌 오렌지를 손에 넣어 다른 아이에게 오렌지를 전달하지 못하게 한다면 그룹 전체가 게임의 목표를 달성할 수 없다는 것을 &gt; 재빨리 알아챌 것입니다. 이 때, 누군가 자신의 이니셜이 적힌 오렌지를 차지하여 게임에서 “승리”하는 것이 목적이 아니라, 모두가 자신의 이니셜이 적힌 오렌지를 가질 때 &gt; 게임 퍼즐을 풀 수 있다는 것을 강조할 필요가 있다. 2.5.2.2 후속 토론 아이는 문제를 해결하기 위해 어떤 전략을 사용했습니까? 실생활에서는 어떤 장소에서 교착상태(deadlock)를 경험했습니까? (교통 체증, 야구경기에서 베이스를 도는 주루선수, 많은 사람이 동시에 출구를 통과하려는 모습 등) 2.5.3 확장 활동 좀더 작거나 큰 원을 그려 활동을 확대해 보자 아이들이 새로운 규칙을 제시하도록 하자 어떤 말을 하지 말고 활동을 진행해 보자 아이들이 한 줄로 앉던가, 두명 이상의 아이가 옆에 앉도록 형태를 바꿔서 진행해 보자. 몇가지 확장활동 제안 예시가 다음에 있다. 2.5.4 컴퓨터 과학 핵심 개념 도로, 전화, 컴퓨터 시스템 같이 많은 네트워크에서 라우팅(Routing)과 교착상태(Deadlock)는 흔한 문제다. 엔지니어들은 이런 문제를 어떻게 해결할 것인가, 문제를 풀기 쉬운 네트워크를 어떻게 설계할지에 대해서 많은 연구를 한다. 라우팅, 정체, 교착상태는 많은 네트워크에서 좌절감을 안겨줄 정도의 문제를 제시한다. 출퇴근 혼잡 시간대에 교통상황을 상상해 보세요. 뉴욕이나 서울 도로에 너무나 많은 자동차가 흘러나와 혼잡한 상황이 되어서 어떤 자동차도 움직일 수 없는 교착상태가 되는 경우가 종종 있습니다. 때때로, 은행 같은 금융업무용 컴퓨터가 다운이 될 때는 통신 네트워크에 교착상태가 원인입니다. 라우팅이 쉽고, 효율적이며, 정체가 최소화되는 네트워크를 설계하는 것이 많은 엔지니어들이 직면한 어려운 문제입니다. 여러 사람이 동일 시간대에 동일한 데이터를 요구하는 것은 자주 있는 일입니다. 고객의 예금 잔고와 같은 데이터를 갱신할 때, 그 찰라의 시간에 “잠금(lock)”을 걸어 타인에게 보이지 않도록 하는 것이 중요합니다. 만약 잠겨 있지 않으면, 다른 누군가가 데이터를 동시에 갱신해서, 잘못된 예금 잔고가 기록되어 버릴 수도 있기 때문입니다. 그러나, 이러한 잠금 설정이 다른 항목의 잠금 설정에 의해 충돌나거나 간섭이 발생하는 상황이 되면 교착 상태가 발생할지 모릅니다. 컴퓨터 설계에 있어 가장 획기적인 업적 중 하나는 병렬 컴퓨팅(parallel computing)의 등장입니다. PC같은 개인용 컴퓨터 수백, 수천 개의 중앙처리장치(processor)를 네트워크로 결합하여 하나의 강력한 컴퓨터를 만든 것입니다. 이러한 병렬 컴퓨터를 작동시키기 위해서 오렌지 게임과 같은 많은 문제가 네트워크에서 항상 (훨씬 빠르게) 재현되고 있는 것입니다. 2.6 돌명판(Tablets of Stone) - 네트워크 통신 프로토콜 2.6 개요 컴퓨터는 메시지를 통해 인터넷으로 서로 대화한다. 하지만, 인터넷은 신뢰성이 없어서, 때때로 메시지 일부가 유실되기도 한다. 메시지에 특정 정보 일부(bits of information)를 추가해서 송신이 제대로 되었는지 확실히 한다. 이 정보가 프로토콜을 구성한다. 2.6 교과학습 연계 수학 : 로직과 추론 개발 국어(English) : 의사소통, 대인관계 경청(interpersonal listening) 2.6 기술 협력하여 문제 해결하기 논리적 추론하기 2.6 나이 9세 이상 2.6 학습 교재 각 아이들에게 필요한 것 많은 공백 명판(Tablet) 각 배달원이 필요한 것 메시지 실행 카드 한 벌 선생님이 필요한 것 초시계 2.6.1 돌명판(Tablets of Stone) 2.6.1.1 들어가며 이 활동에서 학생들은 어떻게 서로 다른 통신 방법이 성공적으로 운영될 수 있는지 생각하게 될 것이다. 장소에 규칙과 절차를 살펴봄으로써, 학생들은 통신 프로토콜에 자연스럽게 소개된다. 역할극 시나리오를 직접 수행해봄으로써, 학생들은 신뢰성이 없는 환경아래에서 자신만의 프로토콜을 검정하게 되는데, 인터넷 패킷 교환(packat switching), 좀더 구체적으로 TCP/IP 환경과 유사하다. 2.6.1.2 준비 (30분) 먼저 카드를 모은다. (아래) 활동카드를 출력하고 가위로 자른다. 그럼 게임 준비가 되었다. 다음, 학생이 전송할 메시지를 정한다. 중요한 것은 메시지가 국문(영문) 문장이거나 구조를 다시 조합할 수 있는 것은 안된다. “1LHC255HD(RLLS” 같은 것이 적합한 메시지다 혹은 전화번호. “명판(tablet)” 사본을 출력한다. 각 명판은 문자 혹은 숫자 6개를 넣을 수 있는 자리가 있다. 그래서, 한 명판에 전체 메시지를 전부 맞추어 넣을 수는 없다. 얼마나 오랜 시간동안 게임을 할것인지에 달려있지만, 학생당 대략 명판 30개가 필요할 것이다. 주의: 활동카드가 3가지 유형이 있다— 지연(delay), 전달금지(don’t deliver), 전달(deliver). 세가지 유형 활동 카드 비율을 조절해서 메시지 전달자 품질을 조정할 수 있다. “전달(deliver)” 활동카드를 좀더 많이 주면 좀더 신뢰성 있는 메시지 전달자가 된다. 좀더 &gt; “지연(delay)”과 “전달금지(don’t deliver)”를 주게되면, 덜 신뢰성 있는 네트워크를 의미하게 된다. 이러한 활동카드는 컴퓨터 네트워크/통신 채털과 유사하다. 2.6.1.3 게임하기 학급을 쌍(pair)으로 나눈다. 서로를 볼 수 없게 하거나 서로 의사소통할 수 없게 각 쌍이 떨어져 앉아있게 하는 것이 매우 중요하다. 교실 두개가 이상적이지만, 교실 반대편에 학생들이 앉아 있는 것으로도 충분하다. 한쪽에 다른 상대방에게 전달할 메시지를 나눠준다. “활동카드(Action Cards)”를 섞고 메시지 전달자를 선정한다. 만약 홀수가 나오면, 그 학생이 메시지 전달자가 될 수 있다. 만약 학급이 크다면, 한명 이상의 메시지 전달자가 필요할 수 있다. . 한 학생이 이제 명판에 적고 명판을 메시지 전달자에게 건내준다. 명판위에 적어도 다른 사람 이름이 있어야 한다. . 메시지 전달자가 가장 위에 있는 활동카드를 뽑고, 뒤집어 읽고, 그것을 사용해서 명판으로 무엇을 할지 결정한다. . 4번과 5번 단계를 각 명판으로 반복한다. 약 5분간의 혼란과 좌절 뒤에, 학생들은 이름만으로는 프로토콜로 충북히 만족스럽지 않다는 것을 깨달아야 한다. 수업을 중단시키고, 토론하자… 학생들이 갖는 첫번째 이슈가 무엇일까? 순서일까? 혹시, 6개 자리중에서 하나에 명판 숫자를 넣어 사용하는 것이 최선이 아닐까? 이것이 의미하는 바는 실제 데이터에는 적은 공간이 할당된다는 의미가 된다 — 이제 사용해야하는 명판 숫자에 관해서 이것이 의미하는 바는 무엇일까? 잠시 시간이 흐른 뒤에, 다른 문제를 알아챌지 모른다. 이러한 문제도 또한 토의되어야 한다. 가능한 문제는 명판 분실이 될 수 있고 명판이 전달이 제대로 되었는지 알지 못하고, 명판을 재전송했는지 알지 못하는 것도 있다. 제시할 수 있는 해결책은 받았다는 증명(&gt; acknowledgement)을 다시 보내고, 또다른 명판을 보내기 전에 받았다는 증명을 받을 때가지 기다린다 — 이것이 의미하는 바는 수신 학생에게도 또한 메시지를 송신할 &gt; 빈 명판이 필요하다는 것이다. 그리고, 게임을 다시 시작하기 전에 문자 6개 응답이 무엇을 의미하는지 동의해야 할 것이다. 이 게임에 적어도 학생이 두 명 필요하다. 하지만, 가능하면 많은 학생을 갖기 추천한다. 만약 학급이 크다면, 메시지 전달자를 몇명 고려한다. 다시 한번, 메시지 전달자 숫자를 학급에서 토의하자. 만약 메시지 전달자가 많다면 무엇이 발생할까? 만약 메시지 &gt; 전달자가 한명이면 무엇이 발생할까? 2.6.2 워크시트 활동: 활동카드(Action Cards) 2.6.3 워크시트 활동: 메시지 전달 2.6.4 돌명판(Tablets of Stone) 고대 도시에는 매우 중요한 통치자(Governors)가 많았다. 통치자는 도시가 어떻게 운영되어야 하는지를 결정하고 매우 중요한 결정을 내린다. 통치자 각자는 도시 도처에 서로 다른 집에서 살았다. 통치자들은 종종 통신하고자 했으며, 도시 도처에서 메시지를 주고 받을 필요가 있었다. 통치자는 본인이 살고 있는 집번호로 식별되었고, 통치자는 모두 메시지를 전달하는 &gt; 것을 업으로 하고 있는 메시지 전달자(messenger) 집단에 접근할 수 있다. 메시지를 전송하는 유일한 방식은 커다란 사각형 돌명판(table of stone)에 적는 것이었다. 메시지 전달자는 돌명판을 가지고 목적지까지 들고갔다. 돌명판은 크기가 고정되어서 돌명판에는 정보로 6 조각만 맞춰 넣을 수 있다. 정보 한조각은 문자 하나 혹은 숫자 하나가 될 수 있다. 메시지는 다수 명판에 쪼개질 수 있고, 명판이 매우 무겁기 때문에 한번에 하나만 옮겨 전달 될 수 있다. 메시지 전달자가 건망증이 심하고 게으르기 때문에 항상 올바른 메시지를 전달할지 신뢰를 가질 수 없다. 종종 근무시간에 너무 오래 휴식을 취하거나 도시를 탈출하여 도망가기도 한다. 통치자는 통신을 신뢰성있게 만들 방법을 찾고 싶고, 통치자 모두가 따를 수 있는 규칙 집합을 개발하고자 한다. 이렇게 함으로써, 메시지가 전달여부와 메시지가 올바르게 &gt; 맞는 것인지 알 수 있다. 통치자는 이미 명판에 목적지가 명시되어야 한다고 결정했다. 여러분이 속한 집단에서, 수행할 작업은 통치자가 통신에 사용할 규칙을 개발하는 것이다… 2.6.5 컴퓨터 과학 핵심 개념 인터넷에서, 데이터는 전송을 위해서 패킷(package)으로 쪼개진다. 하지만, 패킷이 돌아다니는 경로(channel)가 항상 신뢰성이 있는 것은 아니다. 때때로 개별 패킷은 손상되고, 유실되거나 순서를 잃어버리기도 한다. 돌명판에서, 명판(tablet)이 패킷이 되고 명판의 내용이 데이터가 된다. 패킷은 데이터와 헤더(header) 정보를 담고 있다. 헤더정보 크기가 얼마나 많은 정보가 전송될 것인지에 영향을 미친다— 패킷 크기가 유한하기 때문에 균형을 맞추어야 한다. TCP와 UDP 같은 인터넷 프로토콜은 신뢰성 있고 효율적인 데이터 전송을 할 수 있도록 이런 요인을 잘 균형맞춘다. 여기 활동은 컴퓨팅 과학의 안쪽(Computing Science Inside) 프로젝트 중 하나를 차용해서 변형했다. 출처 "],
["language.html", "Chapter 3 제 3 부 3.1 보물 찾기 - 유한상태 오토마타 3.2 진군 명령 - 프로그래밍 언어(Programming Languages)", " Chapter 3 제 3 부 컴퓨터에 무엇을 수행할지 지시하기 — 절차의 표현 보물 찾기—유한상태 오토마타 진군 명령—프로그래밍 언어(Programming Languages) 컴퓨터에 무엇을 수행할지 지시하기 컴퓨터는 초당 수백만번 명령에 따라 움직입니다. 컴퓨터에 무엇을 수행해야 할지 지시하기 위해서, 올바른 명령을 주면 좋겠지만, 말처럼 생각만큼 쉬운 일이 아닙니다. 우리는 명령을 받았을 때, 명령의 의미를 해석하기 위해서 상식적으로 생각합니다. “문을 통해서 오세요”라고 누군가 말을 한다면, 실제로 문을 부수고 통과해서 들어오라는 뜻은 아닙니다. 필요하다면 문을 열고 통해서 들어오라는 의미입니다. 컴퓨터는 매우 다릅니다. 만약 모바일 로봇에 컴퓨터가 장착된다면, 명령을 글자 그대로 해석해서 문을 부수고 들어올 수 있는 위험이나 손상이 생길 수 있으니 주의할 필요가 있습니다. 생각 없이 명령을 정확하게 수행만 하는 컴퓨터를 다루는 것에 익술해질 필요가 있습니다. 제 3 부에서는 활동 2개를 통해서 고정된 명령어 집합을 사용하여 문자 그대만 움직이는 기계(컴퓨터)와 상호작용하는 것이 어떤 의미인지를 학습하게 될 것입니다. 첫번째 활동에서는 컴퓨터가 작업할 수 있는 기호, 즉 단어, 숫자, 기호 문자열을 인식하기 위해 컴퓨터가 사용하는 기계, “유한-상태 오토마타(finite-state automata)” 에 대해 배웁니다. 두번째 활동은 인간이 어떻게 컴퓨터와 상호작용하는지 배웁니다. 좋은 프로그래머는 문자 그대로 해석되는 한정된 명령어 집합으로 컴퓨터가 무엇을 수행할지 전달하는 방식에 대해서 이해할 필요가 있습니다. 명령어 목록이 프로그램입니다. 이러한 명령어를 작성하는 프로그래밍 언어가 많이 있지만, 여기서는 컴퓨터 없이도 사용할 수 있는 매우 간단한 언어를 사용할 것입니다. 3.1 보물 찾기 - 유한상태 오토마타 3.1 개요 컴퓨터 프로그램이 문서안에서 문자나 단어, 혹은 다른 컴퓨터 프로그램의 텍스트 같은 기호 순서(sequence)를 종종 처리할 필요가 있다. 컴퓨터 과학자는 이런 작업을 처리하기 위해서 유한상태 오토마타를 사용합니다. “기호는 문서 안의 문자나 단어 또는 프로그램 문장”, “정수는 0~ 9까지 숫자가 늘어선 것”, “실수는 일정 숫자 순서 뒤에 소수점이 1개 있고 다시 숫자가 늘어선 것” 같이 단어나 기호 문자열을 컴퓨터가 인식해야 합니다. 유한상태 오토마타는 명령어 집합을 따라서 컴퓨터가 단어나 기호 문자열을 인식하는지 확인합니다. 유한상태 오토마타에 상응하는 보물지도를 사용하여 활동을 수행합니다. 3.1 교과학습 연계 수학 : 논리와 추론 개발하기 — 패턴을 기술하고 이어가는 단어나 기호 사용하기 사회 연구 영어/국어 3.1 기술 간단한 독도법(지도 읽기) 패턴 인식 논리 명령 이해하기 3.1 나이 9세 이상 3.1 학습 교재 선생님이 필요한 것 섬 카드 한 세트 (지도를 그리려는 아이들에게 지침이 노출되지 않도록 주의하세요.) 복사 마스터: 섬 카드 복사해서 자르기 점선을 따라 접고 카드의 앞면에는 섬의 이름이 뒷면에는 명령이 되도록 풀칠한다. 아아마다 필요한 것 워크시트 활동: 보물섬에 보물로 가는 길을 찾으세요. 펜 또는 연필 선택적으로 발전학습을 위해, 아이마다 필요한 것 워크시트 활동: 보물섬 워크시트 활동: 수수께끼 동전 게임 3.1.1 언플러그드 활동 동영상 한글 동영상 영어 동영상 3.1.2 보물섬 3.1.2.1 들어가며 이번 여정의 목표는 보물섬을 찾는 것입니다. 우호적인 해적선은 여행자를 태우고, 섬 사이를 정해진 항로로만 항해합니다. 각 섬에는 여러분이 선택할 수 있는 두 대의 배 &gt; A,B가 있습니다. 보물섬으로 가는 가장 좋은 항로를 찾아보세요. 섬에 도착하면 A, B 선박에 승선을 요청할 수 있지만, 두 배 모두를 선택할 수는 없습니다. 섬에 있는 사람은 배가 다음에 어느 섬으로 항해할 것인지를 말해 줄 수는 있지만, 해적들이 모든 섬의 지도를 가지고 있지 않습니다. 자신만의 지도를 사용하여 어느 배를 타고, 어느 섬으로 항해했는지 기록하세요. 3.1.2.2 시연 (주목: 아래 지도는 실제 활동에 사용되는 것과 다른 지도입니다.) 슬라이드 혹은 칠판에 아래처럼 3개의 섬으로 이루어진 그림을 그리세요: 다음 두 페이지에 있는 3장의 카드를 복사해서 아이들이 카드를 1장씩 갖게 합니다. 3장의 카드는 실제 활동에서 사용되는 것과 다르다는 것을 알려줍니다. 해적섬에서 시작해서 배A를 선택합니다. 해적섬 카드를 가진 아이는 배A를 난파만을 목적지로 이동합니다. 지도에 그 경로를 기록합니다. 난파만에서 다시 배A를 선택합니다. 아이는 다시 해적섬으로 배의 진로를 말합니다. 지도에 이것을 기록합니다. 이번에는 배B를 선택합니다. 지도에 표시합니다. 이 경로가 선택하게 되면, ’망자의 섬’으로 가서, 꼼짝할 수 없이 갇히게 됩니다. 최종지도는 다음과 같습니다: 3.1.2.3 시연 활동을 위한 카드 3.1.2.4 활동 섬 역할을 수행할 아이 7명을 선택합니다. 아이들은 뒷면에 비밀 명령이 있는 섬 카드를 지니고 있습니다. 교실 내부나 실외에서 적절한 공간에 무작위로 아이들을 배치하세요&gt; . 나머지 아이들은 공백 지도를 가지고 해적섬에서 보물섬으로 가는 항로를 지도에 표시하면서 항해할 것입니다. (보물섬에 갈 아이는 한 번에 한 명만 한정하여 미리 &gt; 목적지를 듣고 못하도록 하는 것이 좋습니다.) 빨리 끝난 아이: 다른 경로를 찾아보세요. 완성된 지도는 아래와 같을 것입니다. 3.1.2.4.1 후속 토론 가장 빠른 항로는 무엇입니까? 매우 느린 항로는 무엇입니까? 몇몇 항로는 반복(loop)을 포함한 항로도 있습니다. 반복을 포함한 항로의 예를 보여줄 수 있습니까? 보물섬에 도착하는 항로의 예를 보여줄 수 있나요? (예를 들어, 항로 BBBABAB과 BBBABBABAB 모두 보물섬에 도착합니다) 3.1.3 워크시트 활동: 보물섬의 보물까지 가는 길을 찾아라. 3.1.3.1 복사 마스터: 섬 카드 3.1.3.1 유한-상태 오토마타(Finite-State Automata) 지도를 그리는 다른 방법은 다음과 같습니다. 섬은 숫자를 포함한 원으로 표현하고, 최종 보물섬은 이중 원으로 표시합니다. 최종 보물섬에 도착하기 위해서 어떤 항로로 항해를 해야 할까요? 주의: 지도 (a)에서는 일련의 항해 순서(sequence)가 홀수개의 A를 가진 경우에만 이중 원(섬 2)에 도착할 수 있습니다. (예: AB, BABAA, or AAABABA). 지도 (b)는 A와 B가 교대로 나타나는 경우에만 이중 원 (섬 1)에 도달할 수 있습니다.Bs (AB, ABAB, ABABAB, …) 지도 (c)는 이동 순서(sequence)에 적어도 하나의 B가 포함되어야 합니다. (B를 포함하지 않은 A, AA, AAA, AAAA, … 은 이중 원(섬 2)에 도달할 수 없습니다.) 3.1.4 워크시트 활동: 보물섬 보물을 잘 숨기셨는지요? 보물을 찾기 얼마나 힘들게 할 수 있을까요? 이제 자신만의 보물지도를 만들어 보세요. 동일한 아이디어를 지도로 표현하는 좀더 복잡한 방식이 다음에 있다. 이 지도는 앞에서 연습한 것과 동일하다. 컴퓨터 과학자는 이러한 빠르고 쉬운 방식을 사용하여 패턴에 대한 경로를 설계한다. 이것을 참조해서 자신만의 항해 계획을 그려보자. 이제 여러분의 해적선의 항해 경로를 명확하게 시각적으로 표현할 수 있다. 그리고 나서 자신만의 공백 지도와 섬 카드를 만들어 보자. 보물섬에 도착하는 가장 효과적인 항해 순서는 어떻게 될 까요? 친구들이 여러분이 작성한 지도를 따라 잘 항해를 할 수 있을까요? A, B 순서 조합에 대해서 알려주고, 친구가 제대로 섬에 도착하는지 알아보세요. 유한상태 오토마타의 개념에 기초하여 다양한 게임과 퍼즐을 만들 수 있습니다. 다음은 지도의 무작위 경로를 따라서 만나게 되는 단어를 적어 나가 자연스럽게 문장을 생성하는 방법입니다. 이제 동일한 개념을 이용하여 새로운 작문 게임을 만들어봅시다. 혹시, 재미있는 코믹 이야기를 만들 수도 있습니다. 3.1.5 워크시트 활동: 수수께끼 동전 게임 한 친구가 인터넷에서 게임을 다운로드 했습니다. 로봇이 동전을 던지면, 앞면이 나올지 뒷면이 나올지를 맞추는 게임이었습니다. 처음에 무척이나 간단해 보였고, 적어도 50대50 가능성이 있다고 생각했습니다. 하지만, 잠시 뒤에 의심스러운 생각이 들었습니다. 동전 던지기에 특정한 패턴이 있는 것처럼 보였습니다. 인간이 게임을 이길 수 없게 게임이 조작되었나? 분명 아닙니다. 게임을 조사하기로 마음먹고, 조(Joe)는 게임에서 동전 던지기 결과를 적기 시작했고, 다음이 동전던지기 결과 찾아낸 것입니다. (h = heads 앞면, t=tails 뒷면) h h t h h t h h h t t h h h h t t h t t t h h h h h t h h h t t t h h h t t t h h h h h h t t h t t t t t h t t h t t t h h h t t h h h t h h h h h h h h h t t h h h t t t t h h h h h t t t t t t t 예측 가능한 패턴을 찾으셨나요? 동전던지기 규칙을 나타내는 아주 간단한 지도가 있습니다. 여러분이 해결할 수 있는지 확인해 보세요. (힌트: 단지 4개의 ‘섬’밖에 없습니다.) 3.1.6 컴퓨터 과학 핵심 개념 컴퓨터 과학에서 컴퓨터가 문자나 이벤트 순서(sequence)를 처리하려고 유한상태 오토마타(finite-state automata)를 사용합니다. 가장 간단 사례로 전화 자동응답 서비스가 있습니다. 전화를 걸면 자동응답 시스템에서 “무슨 서비스를 원한다면… 1번, 다른 무언가를 원한다면 … 2번, 상담원과 직접 통화를 원하시면 3번 버튼을 누르십시오”라는 메시지를 들을 수 있습니다. 전화 숫자 버튼을 누르는 것은 전화 저편에 있는 컴퓨터 유한상태 오토마타에 입력을 주는 것입니다 . 컴퓨터와 대화는 간단할 수도, 매우 복잡할 수도 있습니다. 유한상태 오토마타에는 특유의 무한반복이 존재하기 때문에, 계속해서 동일한 대화를 반복하게 됩니다. 만약 이런 일이 발생한다면, 분명한 시스템 설계에 오류가 있으며, 전화를 거신 여러분은 분명 매우 당황스러울 것입니다. 또 다른 사례는 현금 자동인출기계에서 현금을 인출하는 경우입니다. 현금 자동인출기계 프로그램은 여러분들로 하여금 이벤트 순서를 발생시킬 것입니다. 프로그램 내부에, 모든 가능한 순서가 유한-상태 오토마타로 표현되어 있습니다. 사용자가 키를 누를 때마다 다음 상태로 자동적으로 이동하게 됩니다. 몇몇 상태는 컴퓨터에 지시사항을 담고 있습니다. 예를 들어, “현금 만원을 지불하세요”, “명세표를 출력하세요”, “현금카드를 꺼내세요”. 몇몇 컴퓨터 프로그램은 워크쉬트 보물섬 같은 지도를 사용하여 국어나 영어 문장을 정말 잘 다룹니다. 이들 컴퓨터는 문장을 잘 만들어 낼 뿐 아니라 사용자가 입력하는 문장을 잘 처리하기도 합니다. 1960년대 컴퓨터 과학자가 사람과 대화하는 “Eliza”, 후에 “Eliza Dolittle”라는 프로그램을 만들었습니다. 영화 ’마이 페어 레이디’에서 오드리 헵번이 연기한 꽃 파는 소녀 이름이기도 합니다. 이 프로그램은 마치 자신이 심리치료 전문가처럼 행사하며 “여러분의 가족에 대해서 알려주세요”, “아무쪼록 계속하십시오” 같이 대화를 이끌어 가는 질문을 곧잘 했다. 사실 이 컴퓨터는 아무것도 이해를 하지 못하지만, 그럴듯하게 보였고, 몇몇 사람은 자신이 사람 심리치료 전문가와 대화하고 있다고 생각하기도 했습니다. 컴퓨터가 자연어를 이해하는 데는 서투르지만, 인공언어를 처리하는 것은 꽤 잘 합니다. 프로그래밍 언어는 중요한 인공언어 중 하나입니다. 컴퓨터는 유한상태 오토마타를 사용하여 프로그램을 읽어서 컴퓨터가 “실행할”&quot; 수 있는 컴퓨터 명령어로 변환합니다. 3.1.7 해답과 힌트 3.1.7.1 수수께끼 동전 게임 수수께끼 동전 게임은 동전을 던질 때마다 다음 지도를 사용합니다. 이 지도를 따라가면, 동전을 세번 던질 때마다 처음 두번은 필히 같은 면을 가지는 것을 알 수 있다. 3.2 진군 명령 - 프로그래밍 언어(Programming Languages) 3.2 개요 대체로 컴퓨터는 제한된 명령어 어휘로 구성된 “언어”로 프로그래밍됩니다. 프로그래밍에 대한 가장 힘든 부분 중의 하나는 컴퓨터가 말도 안되는 결과를 생성하더라도, &gt; 지시사항을 글자 한자까지도 지키다는 것입니다. 이번 활동을 통해서 아이들은 프로그래밍의 이러한 점을 경험할 것입니다. 3.2 교과학습 연계 영어 : 대인 관계 듣기 레벨 3 3.2 기술 지침을 주고 받는 것을 이해하기 3.2 나이 7세 이상 3.2 학습 교재 선생님이 필요한 것 다음에 그려진 것 같은 그림 카드 아아마다 필요한 것 연필, 종이, 자 3.2.1 언플러그드 활동 동영상 구분 동영상 순차적 실행 순차적 실행 함수(I) : : 함수(II) : : 조건문 : : 릴레이 프로그래밍 : : 3.2.2 진군 명령 3.2.2.1 들어가며 사람이 지시 명령대로만 움직여 복종하는 것이 좋은 것인지를 토론하자. 예를 들어, 만약 여러분이 닫혀있는 문을 가리키며 “그 문을 통과하십시오”라고 하면 무슨 일이 발생할까요? 컴퓨터는 주어진 명령 목록 그대로 수행합니다. 비록 상식적으로 납득이 가지 않는 것도 정확하게 명령 목록에 적혀진 그대로 수행합니다. 3.2.2.2 시연 예제 아래 지시사항을 따라서 아이들이 그림을 그릴 수 있는지 살펴봅시다. 아래 사각형 중간에 점을 그리세요. 왼쪽 상단 모서리에서 시작해 가운데 점을 지나 오른쪽 아래 모서리에서 끝나는 직선을 그으세요. 왼쪽 아래 모서리에서 시작해 가운데 점을 지나 오른쪽 위 모서리에서 끝나는 직선을 그으세요. 왼쪽 중간 삼각형에 자신의 이름을 쓰세요. 결과를 확인하고 친구의 그림과 비교해 보세요. 결과는 아래와 같은 느낌입니다. 3.2.3 활동 아이를 골라서 개요에 나와 있는 것과 같은 그림을 주세요. 학급의 아이들이 그림을 그릴 수 있도록 선택된 아이가 그림을 묘사합니다. 아이들이 질문을 통해서 묘사하는 지침을 명확히 할 수 있습니다. 이번 활동의 목적은 얼마나 빠르고 정확하게 완료하는지를 확인하는 것입니다. 동일한 활동을 반복하지만, 이번에는 아이들이 질문을 할 수 없습니다. 이번 활동은 아이들이 빨리 쫓아가기가 어렵기 때문에, 좀더 간단한 이미지를 사용하는 것을 권장합니다. 스크린 뒤에서 아이가 지침만 전달하는 방식으로 진행합니다. 이번 활동에서는 어떠한 질문도 허용되지 않고, 커뮤니케이션이 단지 지침의 형태로만 전달됩니다. 마지막 종류의 커뮤니케이션 방식이 프로그램을 작성할 때 프로그래머가 경험하는 것과 동일하다는 것을 일러줍니다. 프로그래머가 컴퓨터에 명령문을 전달하지만, 나중에 실행해 보기까지는 결과를 알 수 없습니다. 아이에게 그림을 그리고 명령문을 작성하게 합니다. 짝을 지어서 혹은 전체 학급이 실습을 진행합니다. 3.2.3.1 변형 종이 비행기를 만드는 명령문을 적어보세요. “앞으로 x 미터 전진하세요”, “90도 왼쪽으로 도세요”, “90도 오른쪽으로 도세요” 같은 명령문을 사용하여 학교 비밀장소에 도착하는 명령문을 작성해 보세요. 아이들은 자신들이 생각한 결과를 얻을 때까지 명령문을 시험하고 가다듬어야 합니다. 눈가리개 게임. 아이 한명의 눈을 눈가리개로 가리고, 지시 명령문에 따라 교실 여기저기를 돌아다니게 해 보세요. 3.2.4 컴퓨터 과학 핵심 개념 컴퓨터는 프로그램(Program)이라고 불리는 명령 목록에 따라 동작합니다. 프로그램은 특별한 작업을 수행하도록 작성되었습니다. 프로그램은 한정된 명령문의 집합으로 특별히 설계된 언어로 작성되었습니다. 프로그램은 컴퓨터가 무엇을 수행해야 하는지를 담고 있습니다. 특정 언어는 다른 언어보다 특정 목적을 수행하는데 더 적합합니다. 어떤 언어를 사용하든지, 프로그래머는 컴퓨터에 실행시키고자 하는 것을 정확하게 전달하는데 능숙해야 합니다. 인간과 달리, 컴퓨터는 터무니 없는 것일지라도 지시명령문의 글자 그대로 수행합니다. 프로그램이 올바르게 작성되었는지도 확인하는 것도 매우 중요합니다. 작은 오류가 아주 큰 문제를 일으킬 수 있습니다. 우주 왕복선 발사, 원자력 발전소, 철도 신호 등 컴퓨터 프로그램의 사소한 오류조차도 발생할 엄청난 결과를 상상해 보세요. 1940년대 초 전자계산기가 고장이 났을 때 내부 전기 릴레이에서 나방 한마리를 제거( “debugged”)해서 고장을 고쳤습니다. 이를 기념하여 오류를 버그(“bug”)라고 하며, 오류 제거하는 것을 “디버깅(debugging”, “벌레 잡기”)라고 부르게 되었습니다. 프로그램이 복잡해질수록, 더 많은 오류가 발생할 가능성은 높아집니다. 미국이 전략방위구상 스타워즈 (“Star Wars”) 프로그램을 진행할 때 커다란 이슈가 되었습니다. 이 &gt; 프로그램은 핵 공격에 대항해 난공불락의 방어체계를 구축하는 컴퓨터로 제어되는 시스템을 구축하고자 했습니다. 몇몇 컴퓨터 과학자는 소프트웨어의 복잡성과 내재된 저신뢰성으로 실현 불가능하다고 주장하였습니다. 가능한 많은 버그를 잡기 위해 소프트웨어를 테스트를 할 수는 있지만, 누군가 미국을 향해서 미사일을 발사해서 실제 시스템을 제대로 동작하는지 시험해야 하는데 이것은 현실적으로 불가능하기 때문입니다. "],
["references.html", "References", " References "]
]
